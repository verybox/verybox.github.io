{"version":3,"file":"static/js/429.89c6ade7.chunk.js","mappings":"4QAKA,IAAIA,EAAU,KAEd,IAEI,GADAA,EAAMC,UACI,MAAND,EAAc,MAAM,IAAIE,MAAM,gB,CACpC,MAAOC,GACL,MAAMC,EAAS,IAAIC,EAAAA,GAAOC,EAAAA,GAC1BN,EAAK,WACDI,EAAOG,WAAW,+CAAgDF,EAAAA,GAAAA,OAAAA,sBAAqC,CACnGG,UAAW,mBAEnB,C,sTCJJ,MAAMJ,EAAS,IAAIC,EAAAA,GAAOC,EAAAA,GAiB1B,IAAIG,EAAS,EA0BP,MAAOC,UAA0BC,EAAAA,EAanCC,YAAYC,EAA6BC,GAGrB,QAAZA,GACAV,EAAOG,WAAW,uDAAwDF,EAAAA,GAAAA,OAAAA,sBAAqC,CAC3GG,UAAW,gBAKfO,MADgB,kBAATF,EACDA,EAEA,aAFKC,GAKfE,KAAKC,kBAAoB,EAEzBD,KAAKE,UAAW,EAEI,kBAATL,GACPM,EAAAA,EAAAA,IAAeH,KAAM,aAAc,IAAIf,EAAUe,KAAKI,WAAWP,OAEjEM,EAAAA,EAAAA,IAAeH,KAAM,aAAcH,IAGvCM,EAAAA,EAAAA,IAAeH,KAAM,YAAa,CAAC,IACnCG,EAAAA,EAAAA,IAAeH,KAAM,QAAS,CAAC,IAC/BG,EAAAA,EAAAA,IAAeH,KAAM,UAAW,CAAC,IACjCG,EAAAA,EAAAA,IAAeH,KAAM,iBAAkBD,MAAMM,iBAG7CL,KAAKM,UAAUC,OAAS,KACpBP,KAAKE,UAAW,EAChBM,OAAOC,KAAKT,KAAKU,WAAWC,SAASC,IACjCZ,KAAKM,UAAUO,KAAKb,KAAKU,UAAUE,GAAIE,QAAQ,GACjD,EAGNd,KAAKM,UAAUS,UAAaC,IACxB,MAAMC,EAAOD,EAAaC,KACpBC,EAASC,KAAKC,MAAMH,GAC1B,GAAiB,MAAbC,EAAON,GAAY,CACnB,MAAMA,EAAKS,OAAOH,EAAON,IACnBU,EAAUtB,KAAKU,UAAUE,GAG/B,UAFOZ,KAAKU,UAAUE,QAEAW,IAAlBL,EAAOA,OACPI,EAAQE,SAAS,KAAMN,EAAOA,QAE9BlB,KAAKyB,KAAK,QAAS,CACfC,OAAQ,WACRJ,QAASH,KAAKC,MAAME,EAAQR,SAC5Ba,SAAUT,EAAOA,OACjBU,SAAU5B,WAGX,CACH,IAAIb,EAAe,KACf+B,EAAO/B,OACPA,EAAQ,IAAID,MAAMgC,EAAO/B,MAAM0C,SAAW,kBAC1C1B,EAAAA,EAAAA,IAAoBhB,EAAO,OAAQ+B,EAAO/B,MAAM2C,MAAQ,OACxD3B,EAAAA,EAAAA,IAAoBhB,EAAO,WAAY8B,IAEvC9B,EAAQ,IAAID,MAAM,iBAGtBoC,EAAQE,SAASrC,OAAOoC,GAExBvB,KAAKyB,KAAK,QAAS,CACfC,OAAQ,WACRvC,MAAOA,EACPmC,QAASH,KAAKC,MAAME,EAAQR,SAC5Bc,SAAU5B,M,OAKf,GAAsB,qBAAlBkB,EAAOa,OAA+B,CAE7C,MAAMC,EAAMhC,KAAKiC,MAAMf,EAAOgB,OAAOC,cACjCH,GAEAA,EAAII,YAAYlB,EAAOgB,OAAOhB,O,MAIlCmB,EAAQC,KAAK,yB,EAOrB,MAAMC,EAAWC,aAAY,KACzBxC,KAAKyB,KAAK,OAAO,GAClB,KACCc,EAASE,OAASF,EAASE,OACnC,CAIInC,gBAA6B,OAAON,KAAK0C,UAAY,CAEzDrC,gBACI,OAAOL,KAAK2C,cAChB,CAEIC,sBACA,OAAO,CACX,CAEAC,iBAAiBC,GACb1D,EAAOG,WAAW,iDAAkDF,EAAAA,GAAAA,OAAAA,sBAAqC,CACrGG,UAAW,mBAEnB,CAEIoD,oBAAgBG,GAChB3D,EAAOG,WAAW,mDAAoDF,EAAAA,GAAAA,OAAAA,sBAAqC,CACvGG,UAAW,sBAEnB,CAEMwD,O,yCACF,OAAO,IACX,G,CAEIC,YAAQF,GACHA,GAEL3D,EAAOG,WAAW,0CAA2CF,EAAAA,GAAAA,OAAAA,sBAAqC,CAC9FG,UAAW,cAEnB,CAEAqB,KAAKkB,EAAgBG,GACjB,MAAMgB,EAAMzD,IAEZ,OAAO,IAAI0D,SAAQ,CAACC,EAASC,KAMzB,MAAMvC,EAAUK,KAAKmC,UAAU,CAC3BvB,OAAQA,EACRG,OAAQA,EACRtB,GAAIsC,EACJK,QAAS,QAGbvD,KAAKyB,KAAK,QAAS,CACfC,OAAQ,UACRJ,QAASH,KAAKC,MAAMN,GACpBc,SAAU5B,OAGdA,KAAKU,UAAUW,OAAO6B,IAAQ,CAAE1B,SAlBhC,SAAkBrC,EAAc+B,GAC5B,OAAI/B,EAAgBkE,EAAOlE,GACpBiE,EAAQlC,EACnB,EAe0CJ,WAEtCd,KAAKE,UAAYF,KAAKM,UAAUO,KAAKC,E,GAEjD,CAEA0C,oBACI,MAAO,qBACX,CAEMC,WAAWC,EAAaC,EAAmBvB,G,yCAC7C,IAAIwB,EAAe5D,KAAK6D,QAAQH,GACZ,MAAhBE,IACAA,EAAeT,QAAQW,IAAIH,GAAOI,MAAMJ,GAC7B3D,KAAKa,KAAK,gBAAiB8C,KAEtC3D,KAAK6D,QAAQH,GAAOE,GAExB,MAAMI,QAAcJ,EACpB5D,KAAKiC,MAAM+B,GAAS,CAAEN,MAAKtB,cAC/B,G,CAEA6B,YAAYC,GACR,OAAQA,EAAMC,MACV,IAAK,QACDnE,KAAKyD,WAAW,QAAS,CAAE,aAAevC,IACtC,MAAM4B,EAAcsB,EAAAA,GAAAA,KAAelD,EAAOmD,QAAQC,WAClDtE,KAAKuE,SAASC,MAAQ1B,EACtB9C,KAAKyB,KAAK,QAASqB,EAAY,IAEnC,MAEJ,IAAK,UACD9C,KAAKyD,WAAW,UAAW,CAAE,2BAA6BvC,IACtDlB,KAAKyB,KAAK,UAAWP,EAAO,IAEhC,MAEJ,IAAK,SACDlB,KAAKyD,WAAWS,EAAMR,IAAK,CAAE,OAAQ1D,KAAKyE,WAAWP,EAAMQ,UAAYxD,IAC7C,MAAlBA,EAAOyD,UAAmBzD,EAAOyD,SAAU,GAC/C3E,KAAKyB,KAAKyC,EAAMQ,OAAQ1E,KAAK4E,UAAUC,UAAU3D,GAAQ,IAE7D,MAEJ,IAAK,KAAM,CACP,MAAM4D,EAAeZ,IACjB,MAAMa,EAAOb,EAAMa,KACnB/E,KAAKgF,sBAAsBD,GAAMhB,MAAMkB,IAC9BA,GACLjF,KAAKyB,KAAKsD,EAAME,EAAQ,GAC1B,EAINH,EAAYZ,GAMZlE,KAAKyD,WAAW,KAAM,CAAE,aAAevC,IACnClB,KAAKkF,QAAQR,QAAQS,GAAkB,OAAXA,EAAEhB,OAAgBxD,QAAQmE,EAAY,IAEtE,K,CAIJ,IAAK,QACL,IAAK,OACL,IAAK,WACL,IAAK,UACL,IAAK,QACD,MAEJ,QACIzC,EAAQ+C,IAAI,aAAclB,GAGtC,CAEAmB,WAAWnB,GACP,IAAIR,EAAMQ,EAAMR,IAEhB,GAAmB,OAAfQ,EAAMC,KAAe,CAErB,GAAInE,KAAKkF,QAAQR,QAAQS,GAAkB,OAAXA,EAAEhB,OAAgBmB,OAC9C,OAEJ5B,EAAM,I,MACH,GAAI1D,KAAKuF,cAAcrB,EAAMA,OAEhC,OAGJ,MAAMF,EAAQhE,KAAK6D,QAAQH,GACtBM,WAEChE,KAAK6D,QAAQH,GACpBM,EAAMD,MAAMC,IACFhE,KAAKiC,MAAM+B,YACThE,KAAKiC,MAAM+B,GAClBhE,KAAKa,KAAK,kBAAmB,CAAEmD,IAAQ,IAE/C,CAEMwB,U,yCAEExF,KAAKM,UAAUmF,aAAexG,EAAAA,mBACvB,IAAIkE,SAASC,IAChBpD,KAAKM,UAAUC,OAAS,WACpB6C,GAAQ,EACZ,EAEApD,KAAKM,UAAUoF,QAAU,WACrBtC,GAAQ,EACZ,CAAC,KAMTpD,KAAKM,UAAUqF,MAAM,IACzB,G,gDCzUG,MAAMC,EACX,+BAOWC,EACX,6BAMWC,EAAsB,CACjCF,EACAC,G,MAwEWE,EAQXnG,YAAY8D,EAAasC,EAAoBC,GAC3CjG,KAAKgG,SAAWA,EAChBhG,KAAK0D,IAAMA,EACX1D,KAAKiG,KAAOA,EACZjG,KAAKkG,kBAAoB,EACzBlG,KAAKmG,WAAY,C,CAGfjC,YACF,OAAQlE,KAAKmE,MACX,IAAK,KACH,OAAOnE,KAAK+E,KACd,IAAK,SACH,OAAO/E,KAAK0E,OACd,QACE,OAAO1E,KAAK0D,I,CAIdS,WACF,OAAOnE,KAAK0D,IAAI0C,MAAM,KAAK,E,CAGzBrB,WACF,MAAMsB,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAiB,OAAbC,EAAM,GACR,MAAM,IAAInH,MAAM,2BAElB,OAAOmH,EAAM,E,CAGX3B,aACF,MAAM2B,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAiB,WAAbC,EAAM,GACR,MAAM,IAAInH,MAAM,2BAElB,MAAMoH,EAAUD,EAAM,GAEhBE,EC4HJ,SAA4BtF,GAChC,GAAa,KAATA,EACF,MAAO,GAGT,OAAOA,EAAKmF,MAAM,MAAMI,KAAIC,IAC1B,GAAc,KAAVA,EACF,MAAO,GAGT,MAAMJ,EAAQI,EAAML,MAAM,KAAKI,KAAIC,GAChB,SAAVA,EAAmB,KAAOA,IAGnC,OAAwB,IAAjBJ,EAAMf,OAAee,EAAM,GAAKA,CAAK,GAEhD,CD5ImBK,CAAkBL,EAAM,IACjC3B,EAAiB,CAAC,EASxB,OAPI6B,EAAOjB,OAAS,IAClBZ,EAAO6B,OAASA,GAEdD,GAAuB,MAAZA,IACb5B,EAAO4B,QAAUA,GAGZ5B,C,CAGTiC,WAEE,OAAO3G,KAAK0D,IAAIkD,QAAQ,MAAQ,GADT,CAAC,QAAS,UAAW,UAAW,QACHA,QAAQ5G,KAAK0D,MAAQ,C,EC7IvE,MAAOmD,UAAoBd,EAK3Be,kBACF,MAAMT,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAIC,EAAM,KAAOT,EAGjB,OAAIS,EAAM,IAAmB,MAAbA,EAAM,GACbU,EAAwBV,EAAM,SAErC,C,CAQAW,gBACF,MAAMX,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAIC,EAAM,KAAOT,EAGjB,OAAIS,EAAM,IAAmB,MAAbA,EAAM,GACbU,EAAwBV,EAAM,SAErC,C,CAQAY,iBACF,MAAMZ,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAKN,EAAoBoB,SAASb,EAAM,IAGxC,OAAIA,EAAM,IAAmB,MAAbA,EAAM,GACA,SAAbA,EAAM,QAEb,C,CAIAc,qBACF,MAAMd,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAIC,EAAM,KAAOR,EAGjB,OAAIQ,EAAM,IAAmB,MAAbA,EAAM,GACA,SAAbA,EAAM,QAEb,C,CAIAe,gBACF,MAAMf,EAAQrG,KAAK0D,IAAI0C,MAAM,KAC7B,GAAIC,EAAM,KAAOR,EAGjB,OAAIQ,EAAM,IAAmB,MAAbA,EAAM,GAmN1B,SACEpF,GAEA,GAAa,KAATA,EACF,OAKF,OAAOA,EACJmF,MAAM,KACNI,KAAIa,GAAcA,EAAWjB,MAAM,OACnCI,KAAIc,GAAe9G,OAAAA,OAAAA,OAAAA,OAAAA,CAAAA,EACK,MAAnB8G,EAAY,IAAc,CAAEC,GAAID,EAAY,KACzB,MAAnBA,EAAY,IAAc,CAAEE,KAAMF,EAAY,MAExD,CAlOaG,CAA0BpB,EAAM,SAEvC,C,EAKA,SAAUqB,EACdxD,GAIA,MAAwB,kBAAVA,GAAsB,WAAYA,CAClD,CAyBM,SAAUyD,EAAmBzD,GACjC,IAAKwD,EAAexD,GAClB,MAAM,IAAIhF,MAAM,uCAGlB,GAAIgF,EAAMnC,SAAW6F,EAAAA,EAAAA,qBACnB,OAqCJ,SACE1D,GAEA,MAAM4C,EAAce,EAAsB3D,EAAM4C,aAC1CE,EAAYa,EAAsB3D,EAAM8C,WACxCC,EAAaa,EAAsB5D,EAAM+C,YAC/C,MACErB,gCAEAkB,EACA,IACAE,EACA,IACAC,CAEJ,CApDWc,CAAkC7D,GACpC,GAAIA,EAAMnC,SAAW6F,EAAAA,EAAAA,mBAC1B,OAmFJ,SACE1D,GAEA,MAAMkD,EAcR,SACEA,GAEA,QAAkB7F,IAAd6F,EACF,MAAO,IAGT,OAAOA,EACJZ,KACC9B,GACEmD,EAAsBnD,EAAO6C,IAC7B,IACAM,EAAsBnD,EAAO8C,QAEhCQ,KAAK,IACV,CA7BoBC,CAAwB/D,EAAMkD,WAC1CD,EAAiBW,EAAsB5D,EAAMiD,gBAC7CF,EAAaa,EAAsB5D,EAAM+C,YAC/C,MACEpB,8BAEAuB,EACA,IACAD,EACA,IACAF,CAEJ,CAlGWiB,CAAgChE,GAEvC,MAAM,IAAIhF,MAAM,oCAAoCgF,IAExD,CAiHA,SAAS2D,EACPM,GAEA,YAAc5G,IAAV4G,EACK,IACEC,MAAMC,QAAQF,GAChBA,EAAMH,KAAK,KAEXG,CAEX,CAEA,SAASL,EAAsBK,GAC7B,YAAc5G,IAAV4G,EACK,IAEAA,EAAMG,UAEjB,CAoBA,SAASvB,EAAwB9F,GAC/B,GAAa,KAATA,EACF,OAGF,MAAMmG,EAAYnG,EAAKmF,MAAM,KAC7B,OAA4B,IAArBgB,EAAU9B,OAAe8B,EAAU,GAAKA,CACjD,C,MC/NamB,EAGX3I,YAA6BgC,GAAA,KAAQ,SAARA,EADrB,KAAiB,kBAbC,G,CAwBpB4G,oBACJC,EACAC,EACAC,G,8CAEAC,EAAiBH,GACjB,MAAMI,QAAsB7I,KAAK8I,iBAKjC,GAJAF,EAAiBH,GAIY,IAAzBC,EAAcpD,OAChB,OAAOtF,KAAK+I,qBACVC,KAAKC,IAAIN,EAAiBE,EAAgB7I,KAAKkJ,mBAAqB,EACpEL,EAAgB,GAOpB,MAAMM,GAAsBC,EAAAA,EAAAA,GAC1BV,EAAcA,EAAcpD,OAAS,GAAGjB,QAEpCgF,EAAiBR,EAAgB7I,KAAKkJ,kBAAoB,EAChE,GAAIC,GAAuBE,EACzB,OAAOrJ,KAAK+I,qBAAqBM,EAAgBR,EAAgB,GAKnE,MAAMS,QAAoCtJ,KAAKuJ,cAC7Cd,EACAC,GAEFE,EAAiBH,GACjB,MAAMe,QAA2CxJ,KAAK+I,qBACpDI,EAAsB,EACtBN,EAAgB,GAGlB,OADAD,EAAiBH,GACV,IAAIa,KAAeE,E,GAC3B,CAUKC,gBACJhB,EACA/D,EACAgF,EACAf,G,8CAEAC,EAAiBH,GACjB,MAAMI,QAAsB7I,KAAK8I,iBAKjC,GAJAF,EAAiBH,GAIW,IAAxBiB,EAAapE,OACf,OAAOtF,KAAK2J,eACVjF,EACAsE,KAAKC,IAAIN,EAAiBE,EAAgB7I,KAAKkJ,mBAAqB,EACpEL,EAAgB,GAOpB,MAAMM,GAAsBC,EAAAA,EAAAA,GAC1BM,EAAaA,EAAapE,OAAS,GAAGxC,aAElCuG,EAAiBR,EAAgB7I,KAAKkJ,kBAAoB,EAChE,GAAIC,EAAsBE,EACxB,OAAOrJ,KAAK2J,eAAejF,EAAQ2E,EAAgBR,EAAgB,GAKrE,MAAMe,QAAuB5J,KAAK6J,kBAChCpB,EACAiB,GAEFd,EAAiBH,GAIjB,MAAMqB,EAAcJ,EACjBhF,QAAOU,IAAOgE,EAAAA,EAAAA,GAAQhE,EAAItC,aAAe8G,EAAe9G,cACxD0D,KAAIpB,GAAO5E,OAAAA,OAAAA,OAAAA,OAAAA,CAAAA,EAAM4E,GAAG,CAAET,SAAS,MAI5BoF,EACJH,EAAe9G,cAAgBkH,OAAOC,mBAClCb,EAAAA,EAAAA,GAAQM,EAAa,GAAG5G,aACxB8G,EAAe9G,YACrB,IAAIoH,QAAkBlK,KAAK2J,eACzBjF,EACAqF,EACAlB,EAAgB,GAYlB,OARAqB,EAAYA,EAAUxF,QACpBU,GACEA,KACCgE,EAAAA,EAAAA,GAAQhE,EAAItC,aAAe8G,EAAe9G,cACzCsG,EAAAA,EAAAA,GAAQhE,EAAI+E,UAAYP,EAAeO,YAG7CvB,EAAiBH,GACV,IAAIqB,KAAgBI,E,GAC5B,CAODE,oBAAoBC,GAClBrK,KAAKkJ,kBAAoBmB,C,CAQbvB,iB,8CACZ,MAAMwB,QAA+BtK,KAAK4B,SAASf,KAAK,mBACxD,OAAOuI,EAAAA,EAAAA,GAAQkB,E,GAChB,CASavB,qBACZgB,EACAQ,G,8CAEA,GAAIR,GAAsBQ,EACxB,MAAO,GAET,MAAMC,EAA0B,GAChC,IAAK,IAAIC,EAAIV,EAAoBU,EAAIF,EAAkBE,IACrDD,EAAWE,KAAK,CACd3I,OAAQ,uBACRG,OAAQ,EAACyI,EAAAA,EAAAA,GAAMF,IAAI,KAWvB,aALgCzK,KAAK4B,SAASgJ,UAAUJ,IACnBK,QACnC,CAACC,EAAKC,IAAUD,EAAIE,OAAOD,IAC3B,IAEgBvE,IAAIyE,E,GACvB,CAOa1B,cACZd,EACAC,G,8CAEA,MAAMxH,EAA0B,GAGhC,IAAK,IAAIuJ,EAAI/B,EAAcpD,OAAS,EAAGmF,GAAK,EAAGA,IAAK,CAClD,MAAMS,EAAWxC,EAAc+B,GACzBU,QAAkBnL,KAAKoL,kBAAiBhC,EAAAA,EAAAA,GAAQ8B,EAAS7G,SAI/D,GAHAuE,EAAiBH,GAGbyC,EAASnG,OAASoG,EAAUpG,KAC9B,MAGF7D,EAAOwJ,KAAKO,EAAgBE,GAC7B,CACD,OAAOjK,EAAOmK,S,GACf,CAQaD,iBAAiBtI,G,8CAC7B,OAAO9C,KAAK4B,SAASf,KAAK,uBAAwB,EAChD8J,EAAAA,EAAAA,GAAM7H,IACN,G,GAEH,CAYa+G,kBACZpB,EACAiB,G,8CAIA,IAAIyB,QAAkBnL,KAAKoL,kBACzBhC,EAAAA,EAAAA,GAAQM,EAAaA,EAAapE,OAAS,GAAGxC,cAEhD8F,EAAiBH,GACjB,IAAK,IAAIgC,EAAIf,EAAapE,OAAS,EAAGmF,GAAK,EAAGA,IAAK,CACjD,MAAMa,EAAS5B,EAAae,GAU5B,GANIa,EAAOxI,cAAgBqI,EAAU9G,SACnC8G,QAAkBnL,KAAKoL,kBAAiBhC,EAAAA,EAAAA,GAAQkC,EAAOxI,eAKrDwI,EAAOC,YAAcJ,EAAUpG,KACjC,MAAO,CACLjC,aAAasG,EAAAA,EAAAA,GAAQkC,EAAOxI,aAC5BqH,UAAUf,EAAAA,EAAAA,GAAQkC,EAAOnB,UAG9B,CACD,MAAO,CACLrH,YAAakH,OAAOC,kBACpBE,SAAUH,OAAOC,kB,GAEpB,CAOiBN,eAChBjF,EACAqF,EACAQ,G,8CAEA,GAAIR,GAAsBQ,EACxB,MAAO,GAET,MAAMiB,EAAW,+BACZ9G,GAAM,CACT+G,WAAWd,EAAAA,EAAAA,GAAMZ,GACjB2B,SAASf,EAAAA,EAAAA,GAAMJ,EAAmB,KAEpC,OAAOvK,KAAK4B,SAASf,KAAK,cAAe,CAAC2K,G,GAC3C,EAGH,SAASP,EAAgBU,GACvB,MAAMzK,EAAM,iBAA4CyK,GAIxD,cAHOzK,EAAO0K,uBACP1K,EAAO2K,oBACP3K,EAAO4K,OACP5K,CACT,CAUA,SAAS6K,EAAUC,EAAYC,GAC7B,MAAMC,EAAqB,IAAIC,IACzBjL,EAAc,GAQpB,OAPA8K,EAAMrL,SAAQyL,IACZ,MAAMC,EAAMJ,EAAOG,GACdF,EAASI,IAAID,KAChBH,EAASK,IAAIF,GACbnL,EAAOwJ,KAAK0B,GACb,IAEIlL,CACT,CAEA,MAAMsL,EAAY,IAAItN,MAAM,aACtB,SAAU0J,EAAiBH,GAC/B,GAAIA,IACF,MAAM+D,CAEV,CCtUM,MAAOC,UACH/M,EAyBRE,YAAY8M,EAAuBC,G,MAEjC,MAAMC,EAASC,EAAAA,gBAAAA,UAA0BH,EAAOE,QAG1CE,EAAiBD,EAAAA,gBAAAA,kBAAkCH,EAAO5M,SAC1DM,EAAayM,EAAAA,gBAAAA,yBACjBC,EACAF,EACA,OAGIG,EAA0B,iBAAAC,IAWhCjN,MARW,IAAIkN,EAAAA,EAA0B,QAAV,EAAAP,EAAO7M,WAAG,QAAIO,EAAWP,IAAKkN,EAAU,CACrEJ,cAAe,OAAAA,QAAa,IAAbA,EAAAA,EAq2BE,qBAAZO,GACI,MAAXA,GACoB,MAApBA,EAAQC,UACiB,MAAzBD,EAAQC,SAASC,KARUC,EAAAA,OAAAA,aAAoCpO,YA11BzCqO,EAAAA,EAAcR,IA5CtC,KAAO,QAAuB,GAUb,KAAAS,yBACf,IAAIC,IAEW,KAAAC,uBAA8C,IAAID,IAyZ3D,KAAAE,cAAiBxJ,IACvB,MAAMrC,EAA4BV,KAAKC,MAAM8C,EAAMjD,MACnD,IAojBJ,SACEY,GAEA,OAZF,SACEA,GAEA,OACEuG,MAAMC,QAAQxG,IACO,QAApBA,EAAQ0B,cAAyDhC,IAAnCM,EAA4BjB,EAE/D,CAKU+M,CAAW9L,EACrB,CAxjBS+L,CAAoB/L,GACvB,OAEF,MAAMgM,EAAahM,EAAQK,OAAOC,aAC5B2L,EAAY9N,KAAKyN,uBAAuBM,IAAIF,GAClD,IAAKC,EACH,OAEF,MAAM3L,EAAenC,KAAKuN,yBAAyBQ,IAAID,GACvD,GAA4B,kBAAxB3L,EAAaJ,OAIjB,OAAQI,EAAaD,OAAO,IAC1B,IAAK,WAAY,CACf,MAAM8L,EAAuB7L,EACvB8L,EAAkBpM,GAClB,cAAEqM,EAAa,eAAEC,GAAmBH,GACpC,OAAE9M,GAAW+M,EAAgB/L,OAC/BgM,EAuiBZ,SACEE,EACAlK,GAEAmK,EAAsBD,EAAYlK,EAAOoK,EAC3C,CA3iBUC,CAA0BJ,EAAgBjN,GACjC2M,IAAeC,EAGxB9N,KAAKwO,qBAAqBV,EAAW5M,EAAQoN,GAG7CtO,KAAKyO,cAAcX,EAAW5M,EAAQoN,GAExC,KACD,CACD,IAAK,OAAQ,CACX,MAAMI,EAAmBvM,EACnBwM,EAAc9M,GACd,cAAEqM,EAAa,eAAEC,GAAmBO,GACpC,OAAExN,GAAWyN,EAAYzM,OAC3BgM,EA6hBZ,SACEE,EACAlK,GAEAmK,EAAsBD,EAAYlK,EAAO0K,EAC3C,CAjiBUC,CAAsBV,EAAgBjN,GAC7B4M,IAAcD,EACvB7N,KAAKwO,qBAAqBV,EAAW5M,EAAQ0N,GAE7C5O,KAAKyO,cAAcX,EAAW5M,EAAQ0N,GAExC,KACD,IAiBG,KAAY,aAAG,KACrB5O,KAAKyN,uBAAuBqB,QAC5B,MAAM,OAAEC,EAAM,YAAEtG,GAkbpB,WACE,IAAIuG,GAAY,EAChB,MAAO,CAAED,OAAQ,IAAOC,GAAY,EAAOvG,YAAa,IAAMuG,EAChE,CArboCC,GAChCjP,KAAKkP,eAAiBH,EACtB,IAAK,MAAM5M,KAAgBnC,KAAKuN,yBAAyB4B,SAClD,OAAYC,EAAAA,EAAAA,GAAAA,UAAAA,OAAAA,GAAAA,YACf,UACQpP,KAAKqP,uBAAuB5G,EAAatG,EAQhD,CAPC,MAAOhD,GACFsJ,KACHpG,EAAQlD,MACN,4BAA4BgD,EAAaD,OAAO,gDAChD/C,EAGL,C,GACD,EAXG,GAaPa,KAAKsP,gBAAgB,EAwFf,KAAwB,yBAAG,KACD,MAA5BtP,KAAKuP,sBACPC,cAAcxP,KAAKuP,qBACnBvP,KAAKuP,yBAAsBhO,GAE7BvB,KAAKkP,gBAAgB,EAtiBrBlP,KAAK4M,OAASA,EAGd5M,KAAKyP,WAAa,IAAIlH,EAAoBvI,MAC1CA,KAAK0P,qBACL1P,KAAKsP,iBACLtP,KAAKkP,eAAiBS,EAAAA,C,CAYxBnM,kBAAkB1D,GAChB,MAAuB,kBAAZA,GAAwBA,KAAW8P,EAAAA,EACrCA,EAAAA,EAAe9P,IAIjB+P,EAAAA,EAAAA,GAAqB/P,E,CAY9BgQ,GAAGC,EAA6B/J,GAC9B,OAAOhG,KAAKgQ,kBAAkBD,EAAW/J,GAAU,E,CAcrDC,KAAK8J,EAA6B/J,GAChC,OAAOhG,KAAKgQ,kBAAkBD,EAAW/J,GAAU,E,CAYrDiK,IAAIF,EAA6B/J,GAC/B,OAAI0B,EAAeqI,GACV/P,KAAKkQ,KAAKH,EAAW/J,GAErBjG,MAAMkQ,IAAIF,EAAW/J,E,CAYhCmK,mBAAmBJ,GACjB,YAAkBxO,IAAdwO,GAA2BrI,EAAeqI,GACrC/P,KAAKoQ,oBAAoBL,GAEzBhQ,MAAMoQ,mBAAmBJ,E,CAYpCxK,cAAcwK,GACZ,YAAkBxO,IAAdwO,GAA2BrI,EAAeqI,GACrC/P,KAAKqQ,eAAeN,GAEpBhQ,MAAMwF,cAAcwK,E,CAY/BO,UAAUP,GACR,YAAkBxO,IAAdwO,GAA2BrI,EAAeqI,GACrC/P,KAAKuQ,WAAWR,GAEhBhQ,MAAMuQ,UAAUP,E,CAW3BC,kBACED,EACA/J,EACAC,GAEA,GAAIyB,EAAeqI,GAAY,EFlH7B,SAAiCA,GACrC,IAAKvP,OAAO2O,OAAOvH,EAAAA,GAAqBV,SAAS6I,EAAUhO,QACzD,MAAM,IAAI7C,MAEN,uBAAA6Q,EAAUhO,kCACgBvB,OAAO2O,OAAOvH,EAAAA,KAGhD,CE2GM4I,CAAuBT,GACvB,MAAM7L,EAAQ,IAAI2C,EAChBc,EAAmBoI,GACnB/J,EACAC,GAIF,OAFAjG,KAAKkF,QAAQwF,KAAKxG,GAClBlE,KAAKiE,YAAYC,GACVlE,IACR,CACC,OAAOD,MAAMiQ,kBAAkBD,EAAW/J,EAAUC,E,CAYxDhC,YAAYC,GAEe,IAAI4B,EAAqB,QAAS,UACtCoB,SAAShD,EAAMC,MAClCnE,KAAKyQ,iBAAiBvM,GAEtBnE,MAAMkE,YAAYC,E,CAYhBT,WACJC,EACAC,EACAvB,EACA8B,G,8CAEA,IAAIN,EAAe5D,KAAK6D,QAAQH,GAGhC,MAAMgN,QAA4B1Q,KAAK8I,iBAGnB,MAAhBlF,IACFA,EAAeT,QAAQW,IAAIH,GAAOI,MAAKJ,GAC9B3D,KAAKa,KAAK,gBAAiB8C,KAEpC3D,KAAK6D,QAAQH,GAAOE,GAEtB,MAAMI,QAAcJ,EAGd+M,QAAuBxN,QAAQW,IAAIH,GACzC3D,KAAKuN,yBAAyBqD,IAAI5M,EAAO,CACvCE,MAAOA,EACPnC,OAAQ,gBACRG,OAAQyO,EACRD,sBACA5C,UAAW9J,EACX6J,WAAY7J,EACZ6M,WAAY,GACZ3C,eAAe,EACfC,eAAgB,KAElBnO,KAAKyN,uBAAuBmD,IAAI5M,EAAOA,GAIvChE,KAAKiC,MAAM+B,GAAS,CAAEN,MAAKtB,c,GAC5B,CAeDX,KAAKsO,GAAgD,2BAAhBe,EAAgB,iCAAhBA,EAAgB,kBACnD,GAAIpJ,EAAeqI,GAAY,CAC7B,IAAI7O,GAAS,EAEb,MAAM6P,EAA8B,GAG9BC,EAAWrJ,EAAmBoI,GAyBpC,OAvBA/P,KAAKkF,QAAUlF,KAAKkF,QAAQR,QAAOR,GAC7BA,EAAMR,MAAQsN,IAIlBC,YAAW,KACT/M,EAAM8B,SAASkL,MAAMlR,KAAM8Q,EAAK,GAC/B,GAEH5P,GAAS,GAELgD,EAAM+B,OACR8K,EAAQrG,KAAKxG,IACN,MAMX6M,EAAQpQ,SAAQuD,IACdlE,KAAKqF,WAAWnB,EAAM,IAGjBhD,CACR,CACC,OAAOnB,MAAM0B,KAAKsO,KAAce,E,CAK9BlG,UAAUuG,G,8CACd,IAAIC,EAAS,EACb,MAAMtQ,EAA4BqQ,EAAM3K,KAAI,IAAuB,IAAtB,OAAEzE,EAAM,OAAEG,GAAQ,EAC7D,MAAO,CACLH,SACAG,SACAqB,QAAS,MACT3C,GAAI,eAAewQ,IACpB,IAGGzP,QAAiB3B,KAAKqR,sBAAsBvQ,GAC5CwQ,EAAgB3P,EAAS4P,MAAKC,KAAOA,EAAErS,QAC7C,GAAImS,EACF,MAAM,IAAIpS,MAAMoS,EAAcnS,MAAO0C,SAGvC,OAAOF,EACJ8P,MAAK,CAACC,EAAIC,IAAQD,EAAG9Q,GAAiB+Q,EAAG/Q,KACzC4F,KAAIgL,GAAKA,EAAEtQ,Q,GACf,CAGDsE,UAGE,OAFAxF,KAAK4R,wBACL5R,KAAK6R,2BACE9R,MAAMyF,S,CASfsM,sBACE,OAAO9R,KAAK4M,SAAWmF,EAAAA,C,CAczB1M,WAAWnB,GACT,IAAIR,EAAMQ,EAAMR,IAGhB,GAAIoC,EAAoBoB,SAAShD,EAAMC,OAErC,GACEnE,KAAKkF,QAAQR,QAAOS,GAAKW,EAAoBoB,SAAS/B,EAAEhB,QAAOmB,OAE/D,YAGG,GAAmB,OAAfpB,EAAMC,KAAe,CAE9B,GAAInE,KAAKkF,QAAQR,QAAOS,GAAgB,OAAXA,EAAEhB,OAAemB,OAC5C,OAEF5B,EAAM,IACP,MAAM,GAAI1D,KAAKuF,cAAcrB,EAAMA,OAElC,OAGF,MAAMF,EAAQhE,KAAK6D,QAAQH,GACtBM,WAIEhE,KAAK6D,QAAQH,GACfM,EAAMD,MAAKC,IACThE,KAAKiC,MAAM+B,YAGThE,KAAKiC,MAAM+B,GACbhE,KAAKa,KAAK,kBAAmB,CAACmD,IAAO,I,CAKtC0L,qBACN1P,KAAK0C,WAAWsP,iBAAiB,UAAWhS,KAAK0N,eACjD1N,KAAK0C,WAAWsP,iBAAiB,SAAUhS,KAAKiS,cAChDjS,KAAK0C,WAAWsP,iBAAiB,OAAQhS,KAAK6R,yB,CAIxCD,wBACN5R,KAAK0C,WAAWwP,oBAAoB,UAAWlS,KAAK0N,eACpD1N,KAAK0C,WAAWwP,oBAAoB,SAAUlS,KAAKiS,cACnDjS,KAAK0C,WAAWwP,oBAAoB,OAAQlS,KAAK6R,yB,CAuGrCxC,uBACZ5G,EACAtG,G,8CAEA,MAAM,UACJ2L,EAAS,OACT/L,EAAM,OACNG,EAAM,WACN2O,EAAU,eACV1C,EAAc,oBACduC,GACEvO,EACJA,EAAa+L,eAAgB,EAC7BC,EAAe7I,OAAS,EACxB,IACE,MAAMuI,QAAmB7N,KAAKa,KAAKkB,EAAQG,GAI3C,OAHA0G,EAAiBH,GACjBtG,EAAa0L,WAAaA,EAC1B7N,KAAKyN,uBAAuBmD,IAAI/C,EAAYC,GACpC5L,EAAO,IACb,IAAK,WAAY,CACf,MAAMiQ,QAAuBC,GAC3B,IACEC,EACErS,KAAKyP,WAAWjH,oBACdC,EACAoI,EACAH,GAtjBO,MACA,GA0jBb,KAAOjI,MAETG,EAAiBH,ID3PrB,SAAyB6J,GAC7B,OAAOvG,EAAOuG,GAAQpO,GAASA,EAAMa,MACvC,EC0PyBwN,CAAe,IAAIJ,KAAmBhE,IAC9CxN,SAAQuD,GAASlE,KAAKwS,kBAAkB1E,EAAW5J,KAC1D,KACD,CACD,IAAK,OAAQ,CACX,MAAMQ,EAAiCxC,EAAO,IAAM,CAAC,EAC/CiQ,QAAuBC,GAC3B,IACEC,EACErS,KAAKyP,WAAWhG,gBACdhB,EACA/D,EACAmM,EACAH,GA3kBO,MACA,GA+kBb,KAAOjI,MAETG,EAAiBH,ID5QrB,SAAqB6J,GACzB,OAAOvG,EAAOuG,GAAQpO,GAAS,GAAGA,EAAMqH,aAAarH,EAAMiG,YAC7D,EC2QyBsI,CAAW,IAAIN,KAAmBhE,IAC1CxN,SAAQuD,GAASlE,KAAK0S,cAAc5E,EAAW5J,KACtD,KACD,EAOJ,CAHA,QACC/B,EAAa+L,eAAgB,EAC7BC,EAAe7I,OAAS,CACzB,C,GACF,CAoBOkN,kBAAkB1E,EAAmB5M,GAC3ClB,KAAKwO,qBAAqBV,EAAW5M,EAAQoN,E,CAIvCoE,cAAc5E,EAAmB5M,GACvClB,KAAKwO,qBAAqBV,EAAW5M,EAAQ0N,E,CAUvCJ,qBACNV,EACA5M,EACA4H,GAEA9I,KAAKyO,cAAcX,EAAW5M,EAAQ4H,GAEtC,MAAM3G,EAAenC,KAAKuN,yBAAyBQ,IAAID,GAClD3L,GAGLnC,KAAK2S,iBAAiBxQ,EAAcjB,E,CAI9BuN,cACNX,EACA5M,EACA4H,GAEA,MAAM3G,EAAenC,KAAKuN,yBAAyBQ,IAAID,GAClD3L,GAMLkM,EACElM,EAAa0O,WAAU,iBAClB3P,GACL4H,E,CAKI6J,iBACNxQ,EACAjB,GAEqBlB,KAAK4S,cAAczQ,EAAa+B,MACrD2O,CAAa3R,E,CASPoO,iBAC0B,MAA5BtP,KAAKuP,sBAGTvP,KAAKuP,oBAAsB/M,aAAY,KAAW4M,EAAAA,EAAAA,GAAAA,UAAAA,OAAAA,GAAAA,YAChD,UACQiD,EAAYrS,KAAKa,KAAK,eA1rBR,IA6rBrB,CAFC,MAAMiS,GACN9S,KAAK0C,WAAWqQ,WACjB,CACH,KA/rBuB,K,CA4sBX1B,sBACZvQ,G,8CAEA,OAAOqC,QAAQW,IAAIhD,EAAQ0F,KAAIwM,GAAOhT,KAAKa,KAAKmS,EAAIjR,OAAQiR,EAAI9Q,U,GACjE,CAGOuO,iBAAiBvM,GACvB,GAAIA,EAAMC,OAASyB,EAAyC,CAC1D,MAAM,YAAEkB,EAAW,UAAEE,EAAS,WAAEC,GAAe/C,EAC1ClE,KAAKyD,WACRS,EAAMR,IACN,CACEkE,EAAAA,EAAAA,qBACA,CAAEd,cAAaE,YAAWC,eAE5BjH,KAAK4S,cAAc1O,GACnBA,EAEH,MAAM,GAAIA,EAAMC,OAAS0B,EAAuC,CAC/D,MAAM,UAAEuB,EAAS,eAAED,EAAc,WAAEF,GAAe/C,EAC7ClE,KAAKyD,WACRS,EAAMR,IACN,CACEkE,EAAAA,EAAAA,mBACA,CAAER,YAAWD,iBAAgBF,eAE/BjH,KAAK4S,cAAc1O,GACnBA,EAEH,KAAyB,UAAfA,EAAMC,KACVnE,KAAKyD,WACR,QACA,CAAC,YACDzD,KAAK4S,cAAc1O,GACnBA,GAEsB,WAAfA,EAAMC,MACVnE,KAAKyD,WACRS,EAAMR,IACN,CAAC,OAAQ1D,KAAKyE,WAAWP,EAAMQ,SAC/B1E,KAAK4S,cAAc1O,GACnBA,E,CAME0O,cAAc1O,GACpB,OAAQA,EAAMC,MACZ,KAAKyB,EACH,OAAO1E,GACLlB,KAAKyB,KACH,CACEM,OAAQ6F,EAAAA,EAAAA,qBACRd,YAAa5C,EAAM4C,YACnBE,UAAW9C,EAAM8C,UACjBC,WAAY/C,EAAM+C,YAEpB/F,GAEN,KAAK2E,EACH,OAAO3E,GACLlB,KAAKyB,KACH,CACEM,OAAQ6F,EAAAA,EAAAA,mBACRR,UAAWlD,EAAMkD,UACjBD,eAAgBjD,EAAMiD,eACtBF,WAAY/C,EAAM+C,YAEpB/F,GAEN,IAAK,QACH,OAAOA,IACL,MAAM4B,EAAcsB,EAAAA,GAAAA,KAAelD,EAAOmD,QAAQC,WAClDtE,KAAKuE,SAASC,MAAQ1B,EACtB9C,KAAKyB,KAAK,QAASqB,EAAY,EAEnC,IAAK,SACH,OAAO5B,IACiB,MAAlBA,EAAOyD,UACTzD,EAAOyD,SAAU,GAEnB3E,KAAKyB,KAAKyC,EAAMQ,OAAQ1E,KAAK4E,UAAUC,UAAU3D,GAAQ,EAE7D,QACE,MAAM,IAAIhC,MAAM,2C,CAgBdgR,KAAKH,EAA6B/J,GACxC,GAAgB,MAAZA,EACF,OAAOhG,KAAKmQ,mBAAmBJ,GAGjC,MAAMgB,EAA8B,GAEpC,IAAIkC,GAAQ,EACZ,MAAMjC,EAAWrJ,EAAmBoI,GAiBpC,OAhBA/P,KAAKkF,QAAUlF,KAAKkF,QAAQR,QAAOR,GAC7BA,EAAMR,MAAQsN,GAAY9M,EAAM8B,UAAYA,MAG5CiN,IAGJA,GAAQ,EACRlC,EAAQrG,KAAKxG,IACN,MAGT6M,EAAQpQ,SAAQuD,IACdlE,KAAKqF,WAAWnB,EAAM,IAGjBlE,I,CAeDoQ,oBAAoBL,GAC1B,IAAIgB,EAA8B,GAClC,GAAiB,MAAbhB,EACFgB,EAAU/Q,KAAKkF,QAEflF,KAAKkF,QAAU,OACV,CACL,MAAM8L,EAAWrJ,EAAmBoI,GACpC/P,KAAKkF,QAAUlF,KAAKkF,QAAQR,QAAOR,GAC7BA,EAAMR,MAAQsN,IAGlBD,EAAQrG,KAAKxG,IACN,IAEV,CAMD,OAJA6M,EAAQpQ,SAAQuD,IACdlE,KAAKqF,WAAWnB,EAAM,IAGjBlE,I,CAeDqQ,eAAeN,GACrB,IAAKA,EACH,OAAO/P,KAAKkF,QAAQI,OAGtB,MAAM0L,EAAWrJ,EAAmBoI,GACpC,OAAO/P,KAAKkF,QAAQR,QAAOR,GAClBA,EAAMR,MAAQsN,IACpB1L,M,CAeGiL,WAAWR,GACjB,GAAiB,MAAbA,EACF,OAAO/P,KAAKkF,QAAQsB,KAAItC,GAASA,EAAM8B,WAGzC,MAAMgL,EAAWrJ,EAAmBoI,GACpC,OAAO/P,KAAKkF,QACTR,QAAOR,GAASA,EAAMR,MAAQsN,IAC9BxK,KAAItC,GAASA,EAAM8B,U,EAkC1B,SAAeoM,EACbc,EACAC,GACqD,IAArDC,EAA2C,4DAAM,E,8CAEjD,IAAIC,EAAe,EACf5I,EAAI,EACR,OACE,IACE,aAAayI,GAcd,CAbC,MAAO/T,GAEP,GADAsL,IACIA,GAAK0I,IAAeC,EAAYjU,GAClC,MAAMA,EAGR,SADMmU,EAAMD,IACPD,EAAYjU,GACf,MAAMA,EAERkU,EACmB,IAAjBA,EAxBgB,IA0BZrK,KAAKuK,IAxBO,IADK,EAyBgCF,EACxD,C,GAEJ,CAED,SAASC,EAAME,GACb,OAAO,IAAIrQ,SAAQC,GAAW6N,WAAW7N,EAASoQ,IACpD,CAEA,SAASnB,EAAeoB,EAAqBD,GAC3C,OAAOrQ,QAAQuQ,KAAK,CAClBD,EACA,IAAItQ,SAAW,CAACwQ,EAAGtQ,IACjB4N,YAAW,IAAM5N,EAAO,IAAInE,MAAM,aAAasU,MAGrD,CAEA,SAASlF,EAAuBpK,GAC9B,OAAOkF,EAAAA,EAAAA,GAAQlF,EAAMG,OACvB,CAEA,SAASuK,EAAmB1K,GAC1B,OAAOkF,EAAAA,EAAAA,GAAQlF,EAAMpB,YACvB,CAmCA,SAASuL,EACPD,EACAlK,EACA4E,GAEA,MAAM8K,EAAqB9K,EAAe5E,GAGpC2P,EAAiBzF,EAAW0F,WAChC3O,GAAK2D,EAAe3D,GAAKyO,EA3gCM,MA6gCT,IAApBC,EACFzF,EAAW9I,OAAS,EAEpB8I,EAAW2F,OAAO,EAAGF,GAEvBzF,EAAW1D,KAAKxG,EAClB,C,uCC5jCA,IAKA,aAkDI,WACoBrE,EAChBmU,EACAC,GAYA,QAZA,IAAAA,IAAAA,EAAAA,CAAAA,GAFgB,KAAApU,IAAAA,EAjCb,KAAAqU,QAAgD,KAChD,KAAAxO,QAA2C,KAC3C,KAAA3E,UAAoD,KACpD,KAAAR,OAA0C,KAC1C,KAAA4T,OAA2D,KAC3D,KAAAC,SAA4C,KACnC,KAAAC,WAAapH,EAAgBoH,WAC7B,KAAAC,KAAOrH,EAAgBqH,KACvB,KAAAC,QAAUtH,EAAgBsH,QAC1B,KAAAC,OAASvH,EAAgBuH,OAKjC,KAAAC,eAAgB,EAChB,KAAAC,UAAW,EACX,KAAAC,cAAuB,GACvB,KAAAC,cAAwB,EACxB,KAAAC,eAAiB,EAIjB,KAAAC,oBAAsB,GACtB,KAAAC,kBAAoB,GACX,KAAAzE,UAAgC,CAAC,EAcpB,MAAtB0D,GAC8B,kBAAvBA,GACP5L,MAAMC,QAAQ2L,GAEdhU,KAAKgV,UAAYhB,EAEjBC,EAAUD,EAEdhU,KAAKiU,QAAUgB,EAAoBhB,IAC9BjU,KAAKiU,QAAQtH,cAAe,CAC7B,GAAyB,qBAAd1N,UAGP,MAAM,IAAIC,MACN,mFAHJc,KAAKiU,QAAQtH,cAAgB1N,S,CAQrCe,KAAKkV,kBACT,CAkXJ,OAhXI1U,OAAAA,eAAWyM,EAAAA,UAAAA,aAAU,C,IAArB,WACI,OAAOjN,KAAKmV,oBAAsB,MACtC,E,IAEA,SAAsBC,GAClBpV,KAAKmV,mBAAqBC,EACtBpV,KAAKqV,KACLrV,KAAKqV,GAAGD,WAAaA,EAE7B,E,gCAEA5U,OAAAA,eAAWyM,EAAAA,UAAAA,iBAAc,C,IAAzB,WACI,IAAIqI,EAAMtV,KAAKqV,GAAKrV,KAAKqV,GAAGE,eAAiB,EACzCC,GAAmB,EAevB,OAdAxV,KAAK2U,cAAchU,SAAQ,SAAAM,GACvB,IAAMwU,EA+WlB,SAA2BxU,GACvB,MAAoB,kBAATA,EAEA,EAAIA,EAAKqE,OACTrE,aAAgByU,YAChBzU,EAAKwU,WACLxU,aAAgB0U,KAChB1U,EAAK2U,UAEZ,CAER,CA1X+BC,CAAkB5U,GACnB,MAAdwU,EACAH,GAAOG,EAEPD,GAAmB,CAE3B,IACIA,GACAxV,KAAK8V,SACD,yGAIDR,CACX,E,gCAEA9U,OAAAA,eAAWyM,EAAAA,UAAAA,aAAU,C,IAArB,WACI,OAAOjN,KAAKqV,GAAKrV,KAAKqV,GAAGU,WAAa/V,KAAK8U,mBAC/C,E,gCAEAtU,OAAAA,eAAWyM,EAAAA,UAAAA,WAAQ,C,IAAnB,WACI,OAAOjN,KAAKqV,GAAKrV,KAAKqV,GAAGtI,SAAW/M,KAAK+U,iBAC7C,E,gCAEAvU,OAAAA,eAAWyM,EAAAA,UAAAA,aAAU,C,IAArB,WACI,OAAOjN,KAAK0U,SAAWzH,EAAgBuH,OAASvH,EAAgBqH,IACpE,E,gCAEOrH,EAAAA,UAAAA,MAAP,SAAanL,EAAekU,GACxBhW,KAAKiW,cAAcnU,EAAMkU,GACzBhW,KAAKkW,WACLlW,KAAK8V,SAAS,0CAClB,EAEO7I,EAAAA,UAAAA,KAAP,SAAYhM,GACR,GAAIjB,KAAK0U,SACL,MAAM,IAAIxV,MAAM,oDACTc,KAAKqV,IAAMrV,KAAKqV,GAAG5P,aAAezF,KAAKsU,KAC9CtU,KAAKqV,GAAGxU,KAAKI,GAEbjB,KAAK2U,cAAcjK,KAAKzJ,EAEhC,EAEOgM,EAAAA,UAAAA,UAAP,WACI,GAAIjN,KAAK0U,SACL,MAAM,IAAIxV,MACN,kEAGRc,KAAKiW,cAAc,IAAM,+BACzBjW,KAAKmW,iBAAY5U,EACrB,EAUO0L,EAAAA,UAAAA,iBAAP,SACI9I,EACA6B,GAEKhG,KAAKsQ,UAAUnM,KAChBnE,KAAKsQ,UAAUnM,GAAQ,IAE3BnE,KAAKsQ,UAAUnM,GAAMuG,KAAK1E,EAC9B,EAEOiH,EAAAA,UAAAA,cAAP,SAAqB/I,GACjB,OAAOlE,KAAKoW,oBAAoBlS,EAAMC,KAAMD,EAChD,EAUO+I,EAAAA,UAAAA,oBAAP,SACI9I,EACA6B,GAEIhG,KAAKsQ,UAAUnM,KACfnE,KAAKsQ,UAAUnM,GAAQnE,KAAKsQ,UAAUnM,GAAMO,QACxC,SAAA2R,GAAK,OAAAA,IAAMrQ,CAAN,IAGjB,EAEQiH,EAAAA,UAAAA,iBAAR,sBACI,IAAIjN,KAAK0U,SAAT,CAGM,mBAAE4B,EAAAA,EAAAA,eAAgB3J,EAAAA,EAAAA,cACxB3M,KAAK8V,SAAS,4BAA4B9V,KAAKH,IAAG,KAClD,IAAMwV,EAAgB,IAAI1I,EAAc3M,KAAKH,IAAKG,KAAKgV,WACvDK,EAAGnB,QAAU,SAAAhQ,GAAS,SAAKiS,YAAYjS,EAAjB,EACtBmR,EAAG3P,QAAU,SAAAxB,GAAS,SAAKqS,YAAYrS,EAAjB,EACtBmR,EAAGtU,UAAY,SAAAmD,GAAS,SAAKwJ,cAAcxJ,EAAnB,EACxBmR,EAAG9U,OAAS,SAAA2D,GAAS,SAAKsS,WAAWtS,EAAhB,EACrBlE,KAAKyW,iBAAmBxF,YAAW,WAG/ByF,EAAKC,sBACLD,EAAKT,gBACLS,EAAKP,iBAAY5U,EACrB,GAAG+U,GACHtW,KAAKqV,GAAKA,C,CACd,EAEQpI,EAAAA,UAAAA,WAAR,SAAmB/I,GAAnB,WACI,GAAKlE,KAAKqV,KAAMrV,KAAK0U,SAArB,CAGQ,IAAAkC,EAAA,aAAAA,kBACR5W,KAAK8V,SAAS,qBACiB,MAA3B9V,KAAKmV,mBACLnV,KAAKqV,GAAGD,WAAapV,KAAKmV,mBAE1BnV,KAAKmV,mBAAqBnV,KAAKqV,GAAGD,WAEtCpV,KAAK2W,sBACD3W,KAAKyU,cACLzU,KAAKoW,oBAAoB,SAAUlS,IAEnClE,KAAKoW,oBAAoB,OAAQlS,GACjClE,KAAKyU,eAAgB,GAEzBzU,KAAK2U,cAAchU,SAAQ,SAAAkB,GAAW,SAAKhB,KAAKgB,EAAV,IACtC7B,KAAK2U,cAAgB,GACrB3U,KAAK6W,kBAAoB5F,YAAW,WAChCyF,EAAKI,uBACLJ,EAAK9B,cAAgB,EACrB8B,EAAK7B,eAAiB,EACtB,IAAMkC,EAAYH,EAAoB,IAAQ,EAC9CF,EAAKZ,SACD,+BAA+BiB,EAA/B,4CAGR,GAAGH,E,CACP,EAEQ3J,EAAAA,UAAAA,cAAR,SAAsB/I,GACdlE,KAAK0U,UAGT1U,KAAKoW,oBAAoB,UAAWlS,EACxC,EAEQ+I,EAAAA,UAAAA,YAAR,SAAoB/I,GAApB,WACI,IAAIlE,KAAK0U,SAAT,CAGM,mBAAEsC,EAAAA,EAAAA,qBAAsBC,EAAAA,EAAAA,gBAS9B,GARAjX,KAAK2W,sBACL3W,KAAK8W,uBACD9W,KAAKqV,KACLrV,KAAK8U,oBAAsB9U,KAAKqV,GAAGU,WACnC/V,KAAK+U,kBAAoB/U,KAAKqV,GAAGtI,SACjC/M,KAAKiW,iBAETjW,KAAKoW,oBAAoB,OAAQlS,GAC7BlE,KAAK6U,gBAAkBmC,EACvBhX,KAAKkX,iBACDhT,EACAlE,KAAKmX,yCAHb,CAOA,IAAMC,GAAiBlT,GAAS+S,EAAgB/S,GACnB,mBAAlBkT,EACPpX,KAAKqX,oBACDD,EACAlT,EApRZ,mEAwRQkT,EAAcrT,MAAK,SAAAuT,GACXZ,EAAKhC,UAGTgC,EAAKW,oBACDC,EACApT,EA5RhB,qEA+RQ,G,EAER,EAEQ+I,EAAAA,UAAAA,YAAR,SAAoB/I,GAChBlE,KAAKoW,oBAAoB,QAASlS,GAClClE,KAAK8V,SAAS,kCAClB,EAEQ7I,EAAAA,UAAAA,oBAAR,SACImK,EACAlT,EACAqT,GAEIH,EACApX,KAAKwX,wBAELxX,KAAKkX,iBAAiBhT,EAAOqT,EAErC,EAEQtK,EAAAA,UAAAA,sBAAR,sBACU,eACFwK,EAAAA,EAAAA,kBACAC,EAAAA,EAAAA,kBACAC,EAAAA,EAAAA,uBAEJ3X,KAAK6U,iBACL,IAAM+C,EAAY5X,KAAK4U,cACvB5U,KAAK4U,cAAgB5L,KAAKC,IACtBwO,EACAzO,KAAKuK,IACDvT,KAAK4U,cAAgB+C,EACrBD,IAGRzG,YAAW,WAAM,SAAKiE,kBAAL,GAAyB0C,GAC1C,IAAMC,EAAoBD,EAAY,IAAQ,EAC9C5X,KAAK8V,SACD,uCAAuC+B,EAAgB,YAE/D,EAEQ5K,EAAAA,UAAAA,iBAAR,SACI/I,EACA4T,GAEA9X,KAAK8V,SAASgC,GACd9X,KAAKkW,WACDhS,GACAlE,KAAKoW,oBAAoB,QAASlS,EAE1C,EAEQ+I,EAAAA,UAAAA,SAAR,WACIjN,KAAK0U,UAAW,EAChB1U,KAAK+X,mBACL/X,KAAK2U,cAAgB,GACrB3U,KAAKiW,eACT,EAEQhJ,EAAAA,UAAAA,cAAR,SAAsB+K,EAAoBhC,GACjChW,KAAKqV,KAMVrV,KAAKqV,GAAG3P,QAAUiK,EAClB3P,KAAKqV,GAAGnB,QAAUvE,EAClB3P,KAAKqV,GAAGtU,UAAY4O,EACpB3P,KAAKqV,GAAG9U,OAASoP,EACjB3P,KAAKqV,GAAG1P,MAAMqS,EAAWhC,GACzBhW,KAAKqV,QAAK9T,EACd,EAEQ0L,EAAAA,UAAAA,iBAAR,WACIjN,KAAK2W,sBACL3W,KAAK8W,sBACT,EAEQ7J,EAAAA,UAAAA,oBAAR,WACiC,MAAzBjN,KAAKyW,mBACLwB,aAAajY,KAAKyW,kBAClBzW,KAAKyW,sBAAmBlV,EAEhC,EAEQ0L,EAAAA,UAAAA,qBAAR,WACkC,MAA1BjN,KAAK6W,oBACLoB,aAAajY,KAAK6W,mBAClB7W,KAAK6W,uBAAoBtV,EAEjC,EAEQ0L,EAAAA,UAAAA,oBAAR,SAA4B9I,EAAcD,GAA1C,WACI,OAAQC,GACJ,IAAK,QACGnE,KAAKkU,SACLlU,KAAKkU,QAAQhQ,GAEjB,MACJ,IAAK,QACGlE,KAAK0F,SACL1F,KAAK0F,QAAQxB,GAEjB,MACJ,IAAK,UACGlE,KAAKe,WACLf,KAAKe,UAAUmD,GAEnB,MACJ,IAAK,OACGlE,KAAKO,QACLP,KAAKO,OAAO2D,GAEhB,MACJ,IAAK,OACGlE,KAAKmU,QACLnU,KAAKmU,OAAOjQ,GAEhB,MACJ,IAAK,SACGlE,KAAKoU,UACLpU,KAAKoU,SAASlQ,GAS1B,OALIC,KAAQnE,KAAKsQ,WACbtQ,KAAKsQ,UAAUnM,GACV+T,QACAvX,SAAQ,SAAAqF,GAAY,SAAKmS,aAAanS,EAAU9B,EAA5B,KAErBA,IAAWA,EAAgBkU,gBACvC,EAEQnL,EAAAA,UAAAA,aAAR,SACIjH,EACA9B,GAEwB,oBAAb8B,EACPA,EAASqS,KAAKrY,KAAMkE,GAEpB8B,EAASsS,YAAYD,KAAKrY,KAAMkE,EAExC,EAEQ+I,EAAAA,UAAAA,SAAR,SAAiBpL,GACT7B,KAAKiU,QAAQsE,OAEblW,EAAQ+C,IAAIvD,EAEpB,EAEQoL,EAAAA,UAAAA,kCAAR,WACY,IAiCGuL,EAjCHxB,EAAA,aAAAA,qBACR,MAAO,6BAA6BA,EAAoB,KAgC7CwB,EA/BP,WAgCK,IA/BLxB,EA+BSwB,EAAOA,EAAC,KA9BpB,yBACL,EA5buBvL,EAAAA,gBAAqC,CACxD2J,kBAAmB,IACnBN,eAAgB,IAChBiC,OAAO,EACPd,kBAAmB,IACnBC,kBAAmB,IACnBV,qBAAsBhN,OAAOyO,kBAC7Bd,uBAAwB,IACxBV,gBAAiB,WAAM,UACvBtK,mBAAepL,GAGI0L,EAAAA,WAAa,EACbA,EAAAA,KAAO,EACPA,EAAAA,QAAU,EACVA,EAAAA,OAAS,EA8apC,C,CA9bA,GAgcA,SAASgI,EAAoBhB,GACzB,IAAM/S,EAAc,CAAC,EAQrB,OAPAV,OAAOC,KAAKwM,EAAgByL,iBAAiB/X,SAAQ,SAAA0L,GACjD,IAAMtJ,EAASkR,EAAgB5H,GAC/BnL,EAAOmL,QACO9K,IAAVwB,EACOkK,EAAgByL,gBAAwBrM,GACzCtJ,CACd,IACO7B,CACX,CAmBA,SAASyO,IAET,C,IA/dqB1C,C","sources":["../node_modules/@ethersproject/providers/src.ts/browser-ws.ts","../node_modules/@ethersproject/providers/src.ts/websocket-provider.ts","../node_modules/alchemy-sdk/src/internal/internal-types.ts","../node_modules/alchemy-sdk/src/internal/ethers-event.ts","../node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","../node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts","../node_modules/sturdy-websocket/src/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\n\nlet WS: any = null;\n\ntry {\n    WS = (WebSocket as any);\n    if (WS == null) { throw new Error(\"inject please\"); }\n} catch (error) {\n    const logger = new Logger(version);\n    WS = function() {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    }\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n","\"use strict\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nimport { Event } from \"./base-provider\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\n\nlet NextId = 1;\n\nexport type InflightRequest = {\n     callback: (error: Error, result: any) => void;\n     payload: string;\n};\n\nexport type Subscription = {\n    tag: string;\n    processFunc: (payload: any) => void;\n};\n\nexport interface WebSocketLike {\n    onopen: ((...args: Array<any>) => any) | null;\n    onmessage: ((...args: Array<any>) => any) | null;\n    onerror: ((...args: Array<any>) => any) | null;\n\n    readyState: number;\n\n    send(payload: any): void;\n    close(code?: number, reason?: string): void;\n}\n\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\n\nexport class WebSocketProvider extends JsonRpcProvider {\n    readonly _websocket: any;\n    readonly _requests: { [ name: string ]: InflightRequest };\n    readonly _detectNetwork: Promise<Network>;\n\n    // Maps event tag to subscription ID (we dedupe identical events)\n    readonly _subIds: { [ tag: string ]: Promise<string> };\n\n    // Maps Subscription ID to Subscription\n    readonly _subs: { [ name: string ]: Subscription };\n\n    _wsReady: boolean;\n\n    constructor(url: string | WebSocketLike, network?: Networkish) {\n\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n\n        if (typeof(url) === \"string\") {\n            super(url, network);\n        } else {\n            super(\"_websocket\", network);\n        }\n\n        this._pollingInterval = -1;\n\n        this._wsReady = false;\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        } else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n\n        defineReadOnly(this, \"_requests\", { });\n        defineReadOnly(this, \"_subs\", { });\n        defineReadOnly(this, \"_subIds\", { });\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n\n        this.websocket.onmessage = (messageEvent: { data: string }) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n\n                } else {\n                    let error: Error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(<any>error, \"code\", result.error.code || null);\n                        defineReadOnly(<any>error, \"response\", data);\n                    } else {\n                        error = new Error(\"unknown error\");\n                    }\n\n                    request.callback(error, undefined);\n\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n\n                }\n\n            } else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result)\n                }\n\n            } else {\n                console.warn(\"this should not happen\");\n            }\n        };\n\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) { fauxPoll.unref(); }\n    }\n\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket(): WebSocketLike { return this._websocket; }\n\n    detectNetwork(): Promise<Network> {\n        return this._detectNetwork;\n    }\n\n    get pollingInterval(): number {\n        return 0;\n    }\n\n    resetEventsBlock(blockNumber: number): void {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n\n    set pollingInterval(value: number) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n\n    async poll(): Promise<void> {\n        return null;\n    }\n\n    set polling(value: boolean) {\n        if (!value) { return; }\n\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n\n    send(method: string, params?: Array<any>): Promise<any> {\n        const rid = NextId++;\n\n        return new Promise((resolve, reject) => {\n            function callback(error: Error, result: any) {\n                if (error) { return reject(error); }\n                return resolve(result);\n            }\n\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n\n            this._requests[String(rid)] = { callback, payload };\n\n            if (this._wsReady) { this.websocket.send(payload); }\n        });\n    }\n\n    static defaultUrl(): string {\n        return \"ws:/\\/localhost:8546\";\n    }\n\n    async _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void> {\n        let subIdPromise = this._subIds[tag];\n        if (subIdPromise == null) {\n            subIdPromise = Promise.all(param).then((param) => {\n                return this.send(\"eth_subscribe\", param);\n            });\n            this._subIds[tag] = subIdPromise;\n        }\n        const subId = await subIdPromise;\n        this._subs[subId] = { tag, processFunc };\n    }\n\n    _startEvent(event: Event): void {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [ \"newHeads\" ], (result: any) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n\n            case \"pending\":\n                this._subscribe(\"pending\", [ \"newPendingTransactions\" ], (result: any) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n\n            case \"filter\":\n                this._subscribe(event.tag, [ \"logs\", this._getFilter(event.filter) ], (result: any) => {\n                    if (result.removed == null) { result.removed = false; }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n\n            case \"tx\": {\n                const emitReceipt = (event: Event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) { return; }\n                        this.emit(hash, receipt);\n                    });\n                };\n\n                // In case it is already mined\n                emitReceipt(event);\n\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [ \"newHeads\" ], (result: any) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n\n    _stopEvent(event: Event): void {\n        let tag = event.tag;\n\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n\n        const subId = this._subIds[tag];\n        if (!subId) { return; }\n\n       delete this._subIds[tag];\n       subId.then((subId) => {\n            if (!this._subs[subId]) { return; }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [ subId ]);\n        });\n    }\n\n    async destroy(): Promise<void> {\n        // Wait until we have connected before trying to disconnect\n        if (this.websocket.readyState === WebSocket.CONNECTING) {\n            await (new Promise((resolve) => {\n                this.websocket.onopen = function() {\n                    resolve(true);\n                };\n\n                this.websocket.onerror = function() {\n                    resolve(false);\n                };\n            }));\n        }\n\n        // Hangup\n        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n        this.websocket.close(1000);\n    }\n}\n","import { EventType, Filter, Listener } from '@ethersproject/abstract-provider';\n\nimport { EthersEvent, deserializeTopics } from './ethers-event';\nimport {\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent\n} from './websocket-backfiller';\n\n/** This file contains internal types used by the SDK and are not exposed to the end user. */\n\ntype JsonRpcId = string | number | null;\n\n/**\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\n * ethers events.\n *\n * This tag is used internally by ethers to track different event filters.\n */\nexport const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-pending-transactions';\n\n/**\n * Prefix for `alchemy_minedTransactions` subscriptions when serializing to ethers events.\n *\n * This tag is used internally by ethers to track different event filters.\n */\nexport const ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-mined-transactions';\n\n/**\n * Array containing all the custom event tags used internally by ethers to track\n * event filters.\n */\nexport const ALCHEMY_EVENT_TYPES = [\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE\n];\n\nexport interface JsonRpcRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: '2.0';\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\ninterface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport interface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\nexport interface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: '2.0';\n  method: 'eth_subscription';\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Event class copied directly over from ethers.js's `BaseProvider` class.\n *\n * This class is used to represent events and their corresponding listeners. The\n * SDK needs to extend this class in order to support Alchemy's custom\n * Subscription API types. The original class is not exported by ethers. Minimal\n * changes have been made in order to get TS to compile.\n */\nexport class Event {\n  readonly listener: Listener;\n  readonly once: boolean;\n  readonly tag: string;\n\n  _lastBlockNumber: number;\n  _inflight: boolean;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash!;\n      case 'filter':\n        return this.filter!;\n      default:\n        return this.tag;\n    }\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n\n    const topics = deserializeTopics(comps[2]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n","import {\n  AlchemyEventFilter,\n  AlchemyEventType,\n  AlchemyMinedTransactionsAddress,\n  AlchemyMinedTransactionsEventFilter,\n  AlchemyPendingTransactionsEventFilter,\n  AlchemySubscription,\n  NonEmptyArray\n} from '../types/types';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  Event\n} from './internal-types';\n\n/**\n * Wrapper class around the ethers `Event` class in order to add support for\n * Alchemy's custom subscriptions types.\n *\n * The serialization and deserialization mechanism requires the order of the\n * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before\n * using a getter on a new event filter, make sure that the position of the\n * field in serialization is correct.\n *\n * The getters on this class deserialize the event tag generated by\n * {@link getAlchemyEventTag} into the original fields passed into the event.\n */\nexport class EthersEvent extends Event {\n  /**\n   * Converts the event tag into the original `fromAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get fromAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `toAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get toAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return deserializeAddressField(comps[2]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `hashesOnly` field in\n   * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.\n   */\n  get hashesOnly(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (!ALCHEMY_EVENT_TYPES.includes(comps[0])) {\n      return undefined;\n    }\n    if (comps[3] && comps[3] !== '*') {\n      return comps[3] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n\n  get includeRemoved(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return comps[2] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n\n  get addresses(): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressesField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n}\n\nexport function isAlchemyEvent(\n  event: AlchemyEventType\n): event is\n  | AlchemyMinedTransactionsEventFilter\n  | AlchemyPendingTransactionsEventFilter {\n  return typeof event === 'object' && 'method' in event;\n}\n\n/**\n * Creates a string representation of an `alchemy_pendingTransaction`\n * subscription filter that is compatible with the ethers implementation of\n * `getEventTag()`. The method is not an exported function in ethers, which is\n * why the SDK has its own implementation.\n *\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\n *\n * @example\n *   ```js\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\n *   const eventTag =  getAlchemyEventTag(\n *   {\n *     \"method\": \"alchemy_pendingTransactions\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   });\n *   ```;\n *\n * @param event\n * @internal\n */\nexport function getAlchemyEventTag(event: AlchemyEventType): string {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n\n  if (event.method === AlchemySubscription.PENDING_TRANSACTIONS) {\n    return serializePendingTransactionsEvent(event);\n  } else if (event.method === AlchemySubscription.MINED_TRANSACTIONS) {\n    return serializeMinedTransactionsEvent(event);\n  } else {\n    throw new Error(`Unrecognized AlchemyFilterEvent: ${event}`);\n  }\n}\n\nexport function verifyAlchemyEventName(eventName: AlchemyEventFilter): void {\n  if (!Object.values(AlchemySubscription).includes(eventName.method)) {\n    throw new Error(\n      `Invalid method name ${\n        eventName.method\n      }. Accepted method names: ${Object.values(AlchemySubscription)}`\n    );\n  }\n}\n\n/**\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\n * compatible event tag.\n *\n * For the example event:\n * ```\n *  {\n *     \"method\": \"alchemy_pendingTransactions\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   }\n * ```\n *\n * The resulting serialization is:\n * `alchemy_pendingTransactions:0xABC:0xDEF|0xGHI:true`\n *\n * If a field is omitted, it is replaced with a `*`.\n */\nfunction serializePendingTransactionsEvent(\n  event: AlchemyPendingTransactionsEventFilter\n): string {\n  const fromAddress = serializeAddressField(event.fromAddress);\n  const toAddress = serializeAddressField(event.toAddress);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    fromAddress +\n    ':' +\n    toAddress +\n    ':' +\n    hashesOnly\n  );\n}\n\n/**\n * Serializes the provided {@link AlchemyPendingTransactionsEventFilter} into an ethers\n * compatible event tag.\n *\n * For the example event:\n * ```\n *  {\n *     \"method\": \"alchemy_minedTransactions\",\n *     \"addresses\": [\n *       {\n *         from: \"0xABC\"\n *       },\n *       {\n *         to: \"0xDEF\",\n *         from: \"0x123\"\n *       }\n *     ]\n *     \"includeRemoved\": false\n *     \"hashesOnly: true\n *   }\n * ```\n *\n * The resulting serialization is:\n * `alchemy_minedTransactions:*,0xABC|0xDEF,0x123:false:true`\n *\n * If a field is omitted, it is replaced with a `*`.\n *\n * The `addresses` array is split by the '|' character, and each to/from address\n * pair is separated by a ',' character.\n *\n */\nfunction serializeMinedTransactionsEvent(\n  event: AlchemyMinedTransactionsEventFilter\n): string {\n  const addresses = serializeAddressesField(event.addresses);\n  const includeRemoved = serializeBooleanField(event.includeRemoved);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    addresses +\n    ':' +\n    includeRemoved +\n    ':' +\n    hashesOnly\n  );\n}\n\nfunction serializeAddressesField(\n  addresses: AlchemyMinedTransactionsAddress[] | undefined\n): string {\n  if (addresses === undefined) {\n    return '*';\n  }\n\n  return addresses\n    .map(\n      filter =>\n        serializeAddressField(filter.to) +\n        ',' +\n        serializeAddressField(filter.from)\n    )\n    .join('|');\n}\n\nfunction serializeAddressField(\n  field: string | Array<string> | undefined\n): string {\n  if (field === undefined) {\n    return '*';\n  } else if (Array.isArray(field)) {\n    return field.join('|');\n  } else {\n    return field;\n  }\n}\n\nfunction serializeBooleanField(field: boolean | undefined): string | undefined {\n  if (field === undefined) {\n    return '*';\n  } else {\n    return field.toString();\n  }\n}\n\nexport function deserializeTopics(data: string): any {\n  if (data === '') {\n    return [];\n  }\n\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\n\nfunction deserializeAddressField(data: string): string | string[] | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  const addresses = data.split('|');\n  return addresses.length === 1 ? addresses[0] : addresses;\n}\n\nfunction deserializeAddressesField(\n  data: string\n): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  // Perform a cast here since TS doesn't know we're guaranteed a non-empty\n  // array from deserializing.\n  return data\n    .split('|')\n    .map(addressStr => addressStr.split(','))\n    .map(addressPair => ({\n      ...(addressPair[0] !== '*' && { to: addressPair[0] }),\n      ...(addressPair[1] !== '*' && { from: addressPair[1] })\n    })) as NonEmptyArray<AlchemyMinedTransactionsAddress>;\n}\n","import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: just fire off each send() separately since we're no longer batching:\n    // TODO: handle errors\n    const batchedBlockHeads = await this.provider.sendBatch(batchParts);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      []\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  LogsSubscription,\n  NewHeadsSubscription,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  VirtualSubscription,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    const response = await this.sendBatchConcurrently(payload);\n    const errorResponse = response.find(r => !!r.error);\n    if (errorResponse) {\n      throw new Error(errorResponse.error!.message);\n    }\n    // The ids are ascending numbers because that's what Payload Factories do.\n    return response\n      .sort((r1, r2) => (r1.id as number) - (r2.id as number))\n      .map(r => r.result);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<JsonRpcResponse[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n"],"names":["WS","WebSocket","Error","error","logger","Logger","version","throwError","operation","NextId","WebSocketProvider","JsonRpcProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","defineReadOnly","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","result","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","value","poll","polling","rid","Promise","resolve","reject","stringify","jsonrpc","static","_subscribe","tag","param","subIdPromise","_subIds","all","then","subId","_startEvent","event","type","BigNumber","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","e","log","_stopEvent","length","listenerCount","destroy","readyState","onerror","close","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE","ALCHEMY_EVENT_TYPES","Event","listener","once","_lastBlockNumber","_inflight","split","comps","address","topics","map","topic","deserializeTopics","pollable","indexOf","EthersEvent","fromAddress","deserializeAddressField","toAddress","hashesOnly","includes","includeRemoved","addresses","addressStr","addressPair","to","from","deserializeAddressesField","isAlchemyEvent","getAlchemyEventTag","AlchemySubscription","serializeAddressField","serializeBooleanField","serializePendingTransactionsEvent","join","serializeAddressesField","serializeMinedTransactionsEvent","field","Array","isArray","toString","WebsocketBackfiller","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","Math","max","maxBackfillBlocks","lastSeenBlockNumber","fromHex","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","push","toHex","sendBatch","reduce","acc","batch","concat","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupe","items","getKey","keysSeen","Set","item","key","has","add","CANCELLED","AlchemyWebSocketProvider","config","wsConstructor","apiKey","AlchemyProvider","alchemyNetwork","protocol","V","SturdyWebSocket","process","versions","node","require","EthersNetwork","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","isResponse","isSubscriptionEvent","physicalId","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","clear","cancel","cancelled","makeCancelToken","cancelBackfill","values","__awaiter","resubscribeAndBackfill","startHeartbeat","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","noop","CustomNetworks","getNetworkFromEthers","on","eventName","_addEventListener","off","_off","removeAllListeners","_removeAllListeners","_listenerCount","listeners","_listeners","verifyAlchemyEventName","customStartEvent","startingBlockNumber","resolvedParams","set","sentEvents","args","stopped","eventTag","setTimeout","apply","parts","nextId","sendBatchConcurrently","errorResponse","find","r","sort","r1","r2","removeSocketListeners","stopHeartbeatAndBackfill","isCommunityResource","DEFAULT_ALCHEMY_API_KEY","addEventListener","handleReopen","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","events","dedupeNewHeads","emitNewHeadsEvent","dedupeLogs","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","_a","reconnect","req","found","f","retryCount","shouldRetry","nextWaitTime","delay","min","ms","promise","race","_","currentBlockNumber","firstGoodIndex","findIndex","splice","protocolsOrOptions","options","onclose","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","ws","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","reason","disposeSocket","shutdown","handleClose","dispatchEventOfType","l","connectTimeout","handleError","handleOpen","connectTimeoutId","_this","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","POSITIVE_INFINITY","DEFAULT_OPTIONS"],"sourceRoot":""}