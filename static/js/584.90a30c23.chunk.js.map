{"version":3,"file":"static/js/584.90a30c23.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/base64/src.ts/browser-base64.ts","../node_modules/@ethersproject/networks/src.ts/_version.ts","../node_modules/@ethersproject/networks/src.ts/index.ts","../node_modules/@ethersproject/providers/src.ts/_version.ts","../node_modules/@ethersproject/abstract-signer/src.ts/index.ts","../node_modules/@ethersproject/abstract-signer/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/_version.ts","../node_modules/@ethersproject/hash/src.ts/id.ts","../node_modules/@ethersproject/hash/src.ts/typed-data.ts","../node_modules/@ethersproject/abstract-provider/src.ts/index.ts","../node_modules/@ethersproject/abstract-provider/src.ts/_version.ts","../node_modules/@ethersproject/basex/src.ts/index.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/decoder.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/lib.ts","../node_modules/@ethersproject/hash/src.ts/ens-normalize/include.ts","../node_modules/@ethersproject/hash/src.ts/namehash.ts","../node_modules/@ethersproject/sha2/src.ts/browser-sha2.ts","../node_modules/@ethersproject/sha2/src.ts/_version.ts","../node_modules/@ethersproject/providers/src.ts/formatter.ts","../node_modules/@ethersproject/constants/src.ts/addresses.ts","../node_modules/@ethersproject/providers/src.ts/base-provider.ts","../node_modules/@ethersproject/constants/src.ts/hashes.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-provider.ts","../node_modules/@ethersproject/web/src.ts/browser-geturl.ts","../node_modules/@ethersproject/web/src.ts/index.ts","../node_modules/@ethersproject/web/src.ts/_version.ts","../node_modules/alchemy-sdk/node_modules/@ethersproject/logger/lib.esm/index.js","../node_modules/alchemy-sdk/node_modules/@ethersproject/logger/lib.esm/_version.js","../node_modules/alchemy-sdk/node_modules/@ethersproject/properties/lib.esm/_version.js","../node_modules/alchemy-sdk/node_modules/@ethersproject/properties/lib.esm/index.js","../node_modules/alchemy-sdk/src/api/alchemy-provider.ts","../node_modules/bech32/index.js"],"sourcesContent":["\"use strict\";\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nexport function decode(textData: string): Uint8Array {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\n\nexport function encode(data: BytesLike): string {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n\n\n","export const version = \"networks/5.7.1\";\n","\"use strict\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Network, Networkish } from \"./types\";\n\nexport {\n    Network,\n    Networkish\n};\n\ntype DefaultProviderFunc = (providers: any, options?: any) => any;\n\ninterface Renetworkable extends DefaultProviderFunc {\n    renetwork: (network: Network) => DefaultProviderFunc;\n};\n\nfunction isRenetworkable(value: any): value is Renetworkable {\n    return (value && typeof(value.renetwork) === \"function\");\n}\n\nfunction ethDefaultProvider(network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (options == null) { options = { }; }\n        const providerList: Array<any> = [];\n\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            } catch(error) { }\n        }\n\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            } catch(error) { }\n        }\n\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            } catch(error) { }\n        }\n\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [ \"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\" ];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            } catch(error) { }\n        }\n\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [ \"ropsten\" ];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            } catch(error) { }\n        }\n\n        if (providerList.length === 0) { return null; }\n\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            } else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n\n        return providerList[0];\n    };\n\n    func.renetwork = function(network: Network) {\n        return ethDefaultProvider(network);\n    };\n\n    return func;\n}\n\nfunction etcDefaultProvider(url: string, network: string | Network): Renetworkable {\n    const func = function(providers: any, options?: any): any {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n\n        return null;\n    };\n\n    func.renetwork = function(network: Network) {\n        return etcDefaultProvider(url, network);\n    };\n\n    return func;\n}\n\nconst homestead: Network = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\n\nconst ropsten: Network = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\n\nconst classicMordor: Network = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n\n// See: https://chainlist.org\nconst networks: { [name: string]: Network } = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n\n    homestead: homestead,\n    mainnet: homestead,\n\n    morden: { chainId: 2, name: \"morden\" },\n\n    ropsten: ropsten,\n    testnet: ropsten,\n\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n\n\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n\n    xdai: { chainId: 100, name: \"xdai\" },\n\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n}\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network: Networkish): Network {\n    // No network (null)\n    if (network == null) { return null; }\n\n    if (typeof(network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n\n    if (typeof(network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) { return null; }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n\n    const standard  = networks[network.name];\n\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof(network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider: DefaultProviderFunc = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        } else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n","export const version = \"providers/5.7.2\";\n","\"use strict\";\n\nimport { BlockTag, FeeData, Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { Bytes, BytesLike } from \"@ethersproject/bytes\";\nimport { Deferrable, defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nconst allowedTransactionKeys: Array<string> = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\n\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n\n// EIP-712 Typed Data\n// See: https://eips.ethereum.org/EIPS/eip-712\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\n// Sub-classes of Signer may optionally extend this interface to indicate\n// they have a private key available synchronously\nexport interface ExternallyOwnedAccount {\n    readonly address: string;\n    readonly privateKey: string;\n}\n\n// Sub-Class Notes:\n//  - A Signer MUST always make sure, that if present, the \"from\" field\n//    matches the Signer, before sending or signing a transaction\n//  - A Signer SHOULD always wrap private information (such as a private\n//    key or mnemonic) in a function, so that console.log does not leak\n//    the data\n\n// @TODO: This is a temporary measure to preserve backwards compatibility\n//        In v6, the method on TypedDataSigner will be added to Signer\nexport interface TypedDataSigner {\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;\n}\n\nexport abstract class Signer {\n    readonly provider?: Provider;\n\n    ///////////////////\n    // Sub-classes MUST implement these\n\n    // Returns the checksum address\n    abstract getAddress(): Promise<string>\n\n    // Returns the signed prefixed-message. This MUST treat:\n    // - Bytes as a binary message\n    // - string as a UTF8-message\n    // i.e. \"0x1234\" is a SIX (6) byte string, NOT 2 bytes of data\n    abstract signMessage(message: Bytes | string): Promise<string>;\n\n    // Signs a transaction and returns the fully serialized, signed transaction.\n    // The EXACT transaction MUST be signed, and NO additional properties to be added.\n    // - This MAY throw if signing transactions is not supports, but if\n    //   it does, sentTransaction MUST be overridden.\n    abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;\n\n    // Returns a new instance of the Signer, connected to provider.\n    // This MAY throw if changing providers is not supported.\n    abstract connect(provider: Provider): Signer;\n\n    readonly _isSigner: boolean;\n\n\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n\n\n    ///////////////////\n    // Sub-classes MAY override these\n\n    async getBalance(blockTag?: BlockTag): Promise<BigNumber> {\n        this._checkProvider(\"getBalance\");\n        return await this.provider.getBalance(this.getAddress(), blockTag);\n    }\n\n    async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n        this._checkProvider(\"getTransactionCount\");\n        return await this.provider.getTransactionCount(this.getAddress(), blockTag);\n    }\n\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        this._checkProvider(\"estimateGas\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.estimateGas(tx);\n    }\n\n    // Populates \"from\" if unspecified, and calls with the transaction\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string> {\n        this._checkProvider(\"call\");\n        const tx = await resolveProperties(this.checkTransaction(transaction));\n        return await this.provider.call(tx, blockTag);\n    }\n\n    // Populates all fields in a transaction, signs it and sends it to the network\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        this._checkProvider(\"sendTransaction\");\n        const tx = await this.populateTransaction(transaction);\n        const signedTx = await this.signTransaction(tx);\n        return await this.provider.sendTransaction(signedTx);\n    }\n\n    async getChainId(): Promise<number> {\n        this._checkProvider(\"getChainId\");\n        const network = await this.provider.getNetwork();\n        return network.chainId;\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        this._checkProvider(\"getGasPrice\");\n        return await this.provider.getGasPrice();\n    }\n\n    async getFeeData(): Promise<FeeData> {\n        this._checkProvider(\"getFeeData\");\n        return await this.provider.getFeeData();\n    }\n\n\n    async resolveName(name: string): Promise<string> {\n        this._checkProvider(\"resolveName\");\n        return await this.provider.resolveName(name);\n    }\n\n\n\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest> {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n\n        const tx = shallowCopy(transaction);\n\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n\n        } else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n\n        return tx;\n    }\n\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    async populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest> {\n\n        const tx: Deferrable<TransactionRequest> = await resolveProperties(this.checkTransaction(transaction))\n\n        if (tx.to != null) {\n            tx.to = Promise.resolve(tx.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n\n            // Prevent this error from causing an UnhandledPromiseException\n            tx.to.catch((error) => {  });\n        }\n\n        // Do not allow mixing pre-eip-1559 and eip-1559 properties\n        const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n            logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n            logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n        }\n\n        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n            // Fully-formed EIP-1559 transaction (skip getFeeData)\n            tx.type = 2;\n\n        } else if (tx.type === 0 || tx.type === 1) {\n            // Explicit Legacy or EIP-2930 transaction\n\n            // Populate missing gasPrice\n            if (tx.gasPrice == null) { tx.gasPrice = this.getGasPrice(); }\n\n        } else {\n\n            // We need to get fee data to determine things\n            const feeData = await this.getFeeData();\n\n            if (tx.type == null) {\n                // We need to auto-detect the intended type of this transaction...\n\n                if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                    // The network supports EIP-1559!\n\n                    // Upgrade transaction from null to eip-1559\n                    tx.type = 2;\n\n                    if (tx.gasPrice != null) {\n                        // Using legacy gasPrice property on an eip-1559 network,\n                        // so use gasPrice as both fee properties\n                        const gasPrice = tx.gasPrice;\n                        delete tx.gasPrice;\n                        tx.maxFeePerGas = gasPrice;\n                        tx.maxPriorityFeePerGas = gasPrice;\n\n                    } else {\n                        // Populate missing fee data\n                        if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                        if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n                    }\n\n                } else if (feeData.gasPrice != null) {\n                    // Network doesn't support EIP-1559...\n\n                    // ...but they are trying to use EIP-1559 properties\n                    if (hasEip1559) {\n                        logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"populateTransaction\"\n                        });\n                    }\n\n                    // Populate missing fee data\n                    if (tx.gasPrice == null) { tx.gasPrice = feeData.gasPrice; }\n\n                    // Explicitly set untyped transaction to legacy\n                    tx.type = 0;\n\n                } else {\n                    // getFeeData has failed us.\n                    logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"signer.getFeeData\"\n                    });\n                }\n\n            } else if (tx.type === 2) {\n                // Explicitly using EIP-1559\n\n                // Populate missing fee data\n                if (tx.maxFeePerGas == null) { tx.maxFeePerGas = feeData.maxFeePerGas; }\n                if (tx.maxPriorityFeePerGas == null) { tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas; }\n            }\n        }\n\n        if (tx.nonce == null) { tx.nonce = this.getTransactionCount(\"pending\"); }\n\n        if (tx.gasLimit == null) {\n            tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                if (forwardErrors.indexOf(error.code) >= 0) {\n                    throw error;\n                }\n\n                return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                    error: error,\n                    tx: tx\n                });\n            });\n        }\n\n        if (tx.chainId == null) {\n            tx.chainId = this.getChainId();\n        } else {\n            tx.chainId = Promise.all([\n                Promise.resolve(tx.chainId),\n                this.getChainId()\n            ]).then((results) => {\n                if (results[1] !== 0 && results[0] !== results[1]) {\n                    logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                }\n                return results[0];\n            });\n        }\n\n        return await resolveProperties(tx);\n    }\n\n\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n\n    _checkProvider(operation?: string): void {\n        if (!this.provider) { logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: (operation || \"_checkProvider\") });\n        }\n    }\n\n    static isSigner(value: any): value is Signer {\n        return !!(value && value._isSigner);\n    }\n}\n\nexport class VoidSigner extends Signer implements TypedDataSigner {\n    readonly address: string;\n\n    constructor(address: string, provider?: Provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n\n    getAddress(): Promise<string> {\n        return Promise.resolve(this.address);\n    }\n\n    _fail(message: string, operation: string): Promise<any> {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n\n    signMessage(message: Bytes | string): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n\n    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n\n    connect(provider: Provider): VoidSigner {\n        return new VoidSigner(this.address, provider);\n    }\n}\n\n","export const version = \"abstract-signer/5.7.0\";\n","export const version = \"hash/5.7.0\";\n","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\n\nexport function id(text: string): string {\n    return keccak256(toUtf8Bytes(text));\n}\n","import { TypedDataDomain, TypedDataField } from \"@ethersproject/abstract-signer\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { id } from \"./id\";\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst NegativeOne: BigNumber = BigNumber.from(-1);\nconst Zero: BigNumber = BigNumber.from(0);\nconst One: BigNumber = BigNumber.from(1);\nconst MaxUint256: BigNumber = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value: BytesLike) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return hexConcat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        if (typeof(value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        }\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        try {\n            return BigNumber.from(value).toString()\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) { throw new Error(\"bad length\"); }\n            return hexlify(bytes);\n        } catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n}\n\nfunction getBaseEncoder(type: string): (value: any) => string {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1): width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne): Zero;\n\n            return function(value: BigNumberish) {\n                const v = BigNumber.from(value);\n\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${ type }`, \"value\", value);\n                }\n\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n\n            return function(value: BytesLike) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${ type }`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType: string;\n    readonly types: Record<string, Array<TypedDataField>>;\n\n    readonly _encoderCache: Record<string, (value: any) => string>;\n    readonly _types: Record<string, string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n\n        defineReadOnly(this, \"_encoderCache\", { });\n        defineReadOnly(this, \"_types\", { });\n\n        // Link struct types to their direct child structs\n        const links: Record<string, Record<string, boolean>> = { };\n\n        // Link structs to structs which contain them as a child\n        const parents: Record<string, Array<string>> = { };\n\n        // Link all subtypes within a given struct\n        const subtypes: Record<string, Record<string, boolean>> = { };\n\n        Object.keys(types).forEach((type) => {\n            links[type] = { };\n            parents[type] = [ ];\n            subtypes[type] = { }\n        });\n\n        for (const name in types) {\n\n            const uniqueNames: Record<string, boolean> = { };\n\n            types[name].forEach((field) => {\n\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { return ;}\n\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n                }\n\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        } else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n        }\n\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Record<string, boolean>) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n            }\n\n            found[type] = true;\n\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) { return; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n\n            delete found[type];\n        }\n        checkCircular(this.primaryType, { });\n\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n\n    _getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value: Array<any>) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(hexConcat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            }\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        }\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v: any) => this._visit(subtype, v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        return logger.throwArgumentError(`unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = shallowCopy(domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        } else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof(value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n","\"use strict\";\n\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { BytesLike, isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { Deferrable, Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { AccessListish, Transaction } from \"@ethersproject/transactions\";\nimport { OnceBlockable } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n///////////////////////////////\n// Exported Types\n\n\nexport type TransactionRequest = {\n    to?: string,\n    from?: string,\n    nonce?: BigNumberish,\n\n    gasLimit?: BigNumberish,\n    gasPrice?: BigNumberish,\n\n    data?: BytesLike,\n    value?: BigNumberish,\n    chainId?: number\n\n    type?: number;\n    accessList?: AccessListish;\n\n    maxPriorityFeePerGas?: BigNumberish;\n    maxFeePerGas?: BigNumberish;\n\n    customData?: Record<string, any>;\n    ccipReadEnabled?: boolean;\n}\n\nexport interface TransactionResponse extends Transaction {\n    hash: string;\n\n    // Only if a transaction has been mined\n    blockNumber?: number,\n    blockHash?: string,\n    timestamp?: number,\n\n    confirmations: number,\n\n    // Not optional (as it is in Transaction)\n    from: string;\n\n    // The raw transaction\n    raw?: string,\n\n    // This function waits until the transaction has been mined\n    wait: (confirmations?: number) => Promise<TransactionReceipt>\n};\n\nexport type BlockTag = string | number;\n\nexport interface _Block {\n    hash: string;\n    parentHash: string;\n    number: number;\n\n    timestamp: number;\n    nonce: string;\n    difficulty: number;\n    _difficulty: BigNumber;\n\n    gasLimit: BigNumber;\n    gasUsed: BigNumber;\n\n    miner: string;\n    extraData: string;\n\n    baseFeePerGas?: null | BigNumber;\n}\n\nexport interface Block extends _Block {\n    transactions: Array<string>;\n}\n\nexport interface BlockWithTransactions extends _Block {\n    transactions: Array<TransactionResponse>;\n}\n\n\nexport interface Log {\n    blockNumber: number;\n    blockHash: string;\n    transactionIndex: number;\n\n    removed: boolean;\n\n    address: string;\n    data: string;\n\n    topics: Array<string>;\n\n    transactionHash: string;\n    logIndex: number;\n}\n\nexport interface TransactionReceipt {\n    to: string;\n    from: string;\n    contractAddress: string,\n    transactionIndex: number,\n    root?: string,\n    gasUsed: BigNumber,\n    logsBloom: string,\n    blockHash: string,\n    transactionHash: string,\n    logs: Array<Log>,\n    blockNumber: number,\n    confirmations: number,\n    cumulativeGasUsed: BigNumber,\n    effectiveGasPrice: BigNumber,\n    byzantium: boolean,\n    type: number;\n    status?: number\n};\n\nexport interface FeeData {\n    lastBaseFeePerGas: null | BigNumber;\n    maxFeePerGas: null | BigNumber;\n    maxPriorityFeePerGas: null | BigNumber;\n    gasPrice: null | BigNumber;\n}\n\nexport interface EventFilter {\n    address?: string;\n    topics?: Array<string | Array<string> | null>;\n}\n\nexport interface Filter extends EventFilter {\n    fromBlock?: BlockTag,\n    toBlock?: BlockTag,\n}\n\nexport interface FilterByBlockHash extends EventFilter {\n    blockHash?: string;\n}\n\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\n\nexport abstract class ForkEvent extends Description {\n    readonly expiry: number;\n\n    readonly _isForkEvent?: boolean;\n\n    static isForkEvent(value: any): value is ForkEvent {\n        return !!(value && value._isForkEvent);\n    }\n}\n\nexport class BlockForkEvent extends ForkEvent {\n    readonly blockHash: string;\n\n    readonly _isBlockForkEvent?: boolean;\n\n    constructor(blockHash: string, expiry?: number) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\n\nexport class TransactionForkEvent extends ForkEvent {\n    readonly hash: string;\n\n    readonly _isTransactionOrderForkEvent?: boolean;\n\n    constructor(hash: string, expiry?: number) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\n\nexport class TransactionOrderForkEvent extends ForkEvent {\n    readonly beforeHash: string;\n    readonly afterHash: string;\n\n    constructor(beforeHash: string, afterHash: string, expiry?: number) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n\nexport type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent;\n\nexport type Listener = (...args: Array<any>) => void;\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class Provider implements OnceBlockable {\n\n    // Network\n    abstract getNetwork(): Promise<Network>;\n\n    // Latest State\n    abstract getBlockNumber(): Promise<number>;\n    abstract getGasPrice(): Promise<BigNumber>;\n    async getFeeData(): Promise<FeeData> {\n        const { block, gasPrice } = await resolveProperties({\n            block: this.getBlock(\"latest\"),\n            gasPrice: this.getGasPrice().catch((error) => {\n                // @TODO: Why is this now failing on Calaveras?\n                //console.log(error);\n                return null;\n            })\n        });\n\n        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n\n        if (block && block.baseFeePerGas) {\n            // We may want to compute this more accurately in the future,\n            // using the formula \"check if the base fee is correct\".\n            // See: https://eips.ethereum.org/EIPS/eip-1559\n            lastBaseFeePerGas = block.baseFeePerGas;\n            maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n            maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n        }\n\n        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n    }\n\n    // Account\n    abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;\n    abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;\n    abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> ;\n    abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n\n    // Execution\n    abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;\n    abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;\n    abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;\n\n    // Queries\n    abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;\n    abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;\n    abstract getTransaction(transactionHash: string): Promise<TransactionResponse>;\n    abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>;\n\n    // Bloom-filter Queries\n    abstract getLogs(filter: Filter): Promise<Array<Log>>;\n\n    // ENS\n    abstract resolveName(name: string | Promise<string>): Promise<null | string>;\n    abstract lookupAddress(address: string | Promise<string>): Promise<null | string>;\n\n    // Event Emitter (ish)\n    abstract on(eventName: EventType, listener: Listener): Provider;\n    abstract once(eventName: EventType, listener: Listener): Provider;\n    abstract emit(eventName: EventType, ...args: Array<any>): boolean\n    abstract listenerCount(eventName?: EventType): number;\n    abstract listeners(eventName?: EventType): Array<Listener>;\n    abstract off(eventName: EventType, listener?: Listener): Provider;\n    abstract removeAllListeners(eventName?: EventType): Provider;\n\n    // Alias for \"on\"\n    addListener(eventName: EventType, listener: Listener): Provider {\n        return this.on(eventName, listener);\n    }\n\n    // Alias for \"off\"\n    removeListener(eventName: EventType, listener: Listener): Provider {\n        return this.off(eventName, listener);\n    }\n\n    // @TODO: This *could* be implemented here, but would pull in events...\n    abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;\n\n    readonly _isProvider: boolean;\n\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n\n    static isProvider(value: any): value is Provider {\n        return !!(value && value._isProvider);\n    }\n\n/*\n    static getResolver(network: Network, callable: CallTransactionable, namehash: string): string {\n        // No ENS...\n        if (!network.ensAddress) {\n            errors.throwError(\n                \"network does support ENS\",\n                errors.UNSUPPORTED_OPERATION,\n                { operation: \"ENS\", network: network.name }\n            );\n        }\n\n        // Not a namehash\n        if (!isHexString(namehash, 32)) {\n            errors.throwArgumentError(\"invalid name hash\", \"namehash\", namehash);\n        }\n\n        // keccak256(\"resolver(bytes32)\")\n        let data = \"0x0178b8bf\" + namehash.substring(2);\n        let transaction = { to: network.ensAddress, data: data };\n\n        return provider.call(transaction).then((data) => {\n            return provider.formatter.callAddress(data);\n        });\n    }\n\n    static resolveNamehash(network: Network, callable: CallTransactionable, namehash: string): string {\n        return this.getResolver(network, callable, namehash).then((resolverAddress) => {\n            if (!resolverAddress) { return null; }\n\n            // keccak256(\"addr(bytes32)\")\n            let data = \"0x3b3b57de\" + namehash(name).substring(2);\n            let transaction = { to: resolverAddress, data: data };\n            return callable.call(transaction).then((data) => {\n                return this.formatter.callAddress(data);\n            });\n\n        })\n    }\n*/\n}\n","export const version = \"abstract-provider/5.7.0\";\n","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\n\nexport class BaseX {\n    readonly alphabet: string;\n    readonly base: number;\n\n    _alphabetMap: { [ character: string ]: number };\n    _leader: string;\n\n    constructor(alphabet: string) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n\n        defineReadOnly(this, \"_alphabetMap\", { });\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n\n    encode(value: BytesLike): string {\n        let source = arrayify(value);\n\n        if (source.length === 0) { return \"\"; }\n\n        let digits = [ 0 ]\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n\n        let string = \"\"\n\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n\n        return string;\n    }\n\n    decode(value: string): Uint8Array {\n        if (typeof(value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n\n        let bytes: Array<number> = [];\n        if (value.length === 0) { return new Uint8Array(bytes); }\n\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0)\n        }\n\n        return arrayify(new Uint8Array(bytes.reverse()))\n    }\n}\n\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\nexport { Base32, Base58 };\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nexport type Numbers = Uint8Array | Array<number>;\nexport type NextFunc = (...args: Array<any>) => number;\n\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array: Array<any>, depth?: number): Array<any> {\n    if (depth == null) { depth = 1; }\n    const result: Array<any> = [];\n\n    const forEach = result.forEach;\n\n    const flatDeep = function (arr: Array<any>, depth: number) {\n        forEach.call(arr, function (val: any) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            } else {\n               result.push(val);\n            }\n        });\n    };\n\n    flatDeep(array, depth);\n    return result;\n}\n\nfunction fromEntries<T extends string | number | symbol = string | number | symbol, U = any>(array: Array<[T, U]>): Record<T, U> {\n    const result: Record<T, U> = <Record<T, U>>{ };\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\n\nexport function decode_arithmetic(bytes: Numbers): Array<number> {\n\tlet pos = 0;\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n\t\n\t// decode the frequency table\n\tlet symbol_count = u16();\n\tlet total = 1;\n\tlet acc = [0, 1]; // first symbol has frequency 1\n\tfor (let i = 1; i < symbol_count; i++) {\n\t\tacc.push(total += u16());\n\t}\n\n\t// skip the sized-payload that the last 3 symbols index into\n\tlet skip = u16();\n\tlet pos_payload = pos;\n\tpos += skip;\n\n\tlet read_width = 0;\n\tlet read_buffer = 0; \n\tfunction read_bit() {\n\t\tif (read_width == 0) {\n\t\t\t// this will read beyond end of buffer\n\t\t\t// but (undefined|0) => zero pad\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\n\t\t\tread_width = 8;\n\t\t}\n\t\treturn (read_buffer >> --read_width) & 1;\n\t}\n\n\tconst N = 31;\n\tconst FULL = 2**N;\n\tconst HALF = FULL >>> 1;\n\tconst QRTR = HALF >> 1;\n\tconst MASK = FULL - 1;\n\n\t// fill register\n\tlet register = 0;\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\n\n\tlet symbols = [];\n\tlet low = 0;\n\tlet range = FULL; // treat like a float\n\twhile (true) {\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\n\t\tlet start = 0;\n\t\tlet end = symbol_count;\n\t\twhile (end - start > 1) { // binary search\n\t\t\tlet mid = (start + end) >>> 1;\n\t\t\tif (value < acc[mid]) {\n\t\t\t\tend = mid;\n\t\t\t} else {\n\t\t\t\tstart = mid;\n\t\t\t}\n\t\t}\n\t\tif (start == 0) break; // first symbol is end mark\n\t\tsymbols.push(start);\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1\n\t\twhile (((a ^ b) & HALF) == 0) {\n\t\t\tregister = (register << 1) & MASK | read_bit();\n\t\t\ta = (a << 1) & MASK;\n\t\t\tb = (b << 1) & MASK | 1;\n\t\t}\n\t\twhile (a & ~b & QRTR) {\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n\t\t\ta = (a << 1) ^ HALF;\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\n\t\t}\n\t\tlow = a;\n\t\trange = 1 + b - a;\n\t}\n\tlet offset = symbol_count - 4;\n\treturn symbols.map(x => { // index into payload\n\t\tswitch (x - offset) {\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n\t\t\tcase 1: return offset + bytes[pos_payload++];\n\t\t\tdefault: return x - 1;\n\t\t}\n\t});\n}\t\n\n\n// returns an iterator which returns the next symbol\nexport function read_payload(v: Numbers): NextFunc {\n\tlet pos = 0;\n\treturn () => v[pos++];\n}\nexport function read_compressed_payload(bytes: Numbers): NextFunc {\n\treturn read_payload(decode_arithmetic(bytes));\n}\n\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i: number): number { \n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\n}\n\nfunction read_counts(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0; i < n; i++) v[i] = 1 + next();\n\treturn v;\n}\n\nfunction read_ascending(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();\n\treturn v;\n}\n\nfunction read_deltas(n: number, next: NextFunc): Array<number> {\n\tlet v = Array(n);\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\n\treturn v;\n}\n\nexport function read_member_array(next: NextFunc, lookup?: Record<number, number>) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next: NextFunc): Record<number, Array<number>> {\n\tlet ret = [];\n\twhile (true) {\n\t\tlet w = next();\n\t\tif (w == 0) break;\n\t\tret.push(read_linear_table(w, next));\n\t}\n\twhile (true) {\n\t\tlet w = next() - 1;\n\t\tif (w < 0) break;\n\t\tret.push(read_replacement_table(w, next));\n\t}\n\treturn fromEntries<number, Array<number>>(flat(ret));\n}\n\nexport function read_zero_terminated_array(next: NextFunc): Array<number> {\n\tlet v = [];\n\twhile (true) {\n\t\tlet i = next();\n\t\tif (i == 0) break;\n\t\tv.push(i);\n\t}\n\treturn v;\n}\n\nfunction read_transposed(n: number, w: number, next: NextFunc): Array<Array<number>> {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\n\n\nfunction read_linear_table(w: number, next: NextFunc): Array<Array<number | Array<number>>> {\n\tlet dx = 1 + next();\n\tlet dy = next();\n\tlet vN = read_zero_terminated_array(next);\n\tlet m = read_transposed(vN.length, 1+w, next);\n\treturn flat(m.map((v, i) => {\n\t  const x = v[0], ys = v.slice(1);\n\t\t//let [x, ...ys] = v;\n\t\t//return Array(vN[i]).fill().map((_, j) => {\n\t\treturn Array(vN[i]).fill(undefined).map((_, j) => {\n\t\t\tlet j_dy = j * dy;\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\n\t\t});\n\t}));\n}\n\nfunction read_replacement_table(w: number, next: NextFunc): Array<[ number, Array<number> ]> {\n\tlet n = 1 + next();\n\tlet m = read_transposed(n, 1+w, next);\n\treturn m.map(v => [v[0], v.slice(1)]);\n}\n\nexport type Branch = {\n    set: Set<number>;\n    node: Node;\n};\n\nexport type Node = {\n    branches: Array<Branch>;\n    valid: number;\n    fe0f: boolean;\n    save: boolean;\n    check: boolean;\n};\n\nexport function read_emoji_trie(next: NextFunc): Node {\n\tlet sorted = read_member_array(next).sort((a, b) => a - b);\n\treturn read();\n\tfunction read(): Node {\n\t\tlet branches = [];\n\t\twhile (true) {\n\t\t\tlet keys = read_member_array(next, sorted);\n\t\t\tif (keys.length == 0) break;\n\t\t\tbranches.push({set: new Set(keys), node: read()});\n\t\t}\n    branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n \t\tlet temp = next();\n \t\tlet valid = temp % 3;\n \t\ttemp = (temp / 3)|0;\n \t\tlet fe0f = !!(temp & 1);\n \t\ttemp >>= 1;\n \t\tlet save = temp == 1;\n \t\tlet check = temp == 2;\n \t\treturn {branches, valid, fe0f, save, check};\n\t}\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\n\nimport { getData } from './include.js';\nconst r = getData();\n\nimport {read_member_array, read_mapped_map, read_emoji_trie} from './decoder.js';\n\n// @TODO: This should be lazily loaded\n\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\n\nfunction explode_cp(name: string): Array<number> {\n    return toUtf8CodePoints(name);\n}\n\nfunction filter_fe0f(cps: Array<number>): Array<number> {\n    return cps.filter(cp => cp != 0xFE0F);\n}\n\nexport function ens_normalize_post_check(name: string): string {\n\tfor (let label of name.split('.')) {\n\t\tlet cps = explode_cp(label);\n\t\ttry {\n\t\t\tfor (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n\t\t\t\tif (cps[i] !== UNDERSCORE) {\n\t\t\t\t\tthrow new Error(`underscore only allowed at start`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n\t\t\t\tthrow new Error(`invalid label extension`);\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow new Error(`Invalid label \"${label}\": ${err.message}`);\n\t\t}\n\t}\n\treturn name;\n}\n\nexport function ens_normalize(name: string): string {\n\treturn ens_normalize_post_check(normalize(name, filter_fe0f));\n}\n\nfunction normalize(name: string, emoji_filter: (a: Array<number>) => Array<number>): string {\n\tlet input = explode_cp(name).reverse(); // flip for pop\n\tlet output = [];\n\twhile (input.length) {\t\t\n\t\tlet emoji = consume_emoji_reversed(input);\n\t\tif (emoji) {\n\t\t\toutput.push(...emoji_filter(emoji));\n\t\t\tcontinue;\n\t\t}\n\t\tlet cp = input.pop();\n\t\tif (VALID.has(cp)) {\n\t\t\toutput.push(cp);\n\t\t\tcontinue;\n\t\t} \n\t\tif (IGNORED.has(cp)) {\n\t\t\tcontinue;\n\t\t}\n\t\tlet cps = MAPPED[cp];\n\t\tif (cps) {\n\t\t\toutput.push(...cps);\n\t\t\tcontinue;\n\t\t}\n\t\tthrow new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n\t}\n\treturn ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\n\nfunction nfc(s: string): string {\n    return s.normalize('NFC');\n}\n\nfunction consume_emoji_reversed(cps: Array<number>, eaten?: Array<number>) {\n\tlet node = EMOJI_ROOT;\n\tlet emoji;\n\tlet saved;\n\tlet stack = [];\n\tlet pos = cps.length;\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\n\twhile (pos) {\n\t\tlet cp = cps[--pos];\n\t\tnode = node.branches.find(x => x.set.has(cp))?.node;\n\t\tif (!node) break;\n\t\tif (node.save) { // remember\n\t\t\tsaved = cp;\n\t\t} else if (node.check) { // check exclusion\n\t\t\tif (cp === saved) break;\n\t\t}\n\t\tstack.push(cp);\n\t\tif (node.fe0f) {\n\t\t\tstack.push(0xFE0F);\n\t\t\tif (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F\n\t\t}\n\t\tif (node.valid) { // this is a valid emoji (so far)\n\t\t\temoji = stack.slice(); // copy stack\n\t\t\tif (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n\t\t\tcps.length = pos; // truncate\n\t\t}\n\t}\n\treturn emoji;\n}\n","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\nimport { decode } from \"@ethersproject/base64\";\n\nimport {read_compressed_payload} from './decoder.js';\n\nexport function getData(): () => number {\n    return read_compressed_payload(decode('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'));\n}\n\n","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { ens_normalize } from \"./ens-normalize/lib\";\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\n\nfunction checkComponent(comp: Uint8Array): Uint8Array {\n    if (comp.length === 0) { throw new Error(\"invalid ENS name; empty component\"); }\n    return comp;\n}\n\nfunction ensNameSplit(name: string): Array<Uint8Array> {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps: Array<Uint8Array> = [ ];\n\n    if (name.length === 0) { return comps; }\n\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) { throw new Error(\"invalid ENS name; empty component\"); }\n\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\n\nexport function ensNormalize(name: string): string {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\n\nexport function isValidName(name: string): boolean {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    } catch (error) { }\n    return false;\n}\n\nexport function namehash(name: string): string {\n    /* istanbul ignore if */\n    if (typeof(name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n\n    let result: string | Uint8Array = Zeros;\n\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n\n    return hexlify(result);\n}\n\nexport function dnsEncode(name: string): string {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n\n    }))) + \"00\";\n}\n","\"use strict\";\n\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\n\nimport { arrayify, BytesLike } from \"@ethersproject/bytes\";\n\nimport { SupportedAlgorithm } from \"./types\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport function ripemd160(data: BytesLike): string {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha256(data: BytesLike): string {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function sha512(data: BytesLike): string {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\n\nexport function computeHmac(algorithm: SupportedAlgorithm, key: BytesLike, data: BytesLike): string {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n\n    return \"0x\" + hash.hmac((<any>hash)[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n\n","export const version = \"sha2/5.7.0\";\n","\"use strict\";\n\nimport { Block, TransactionReceipt, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { AccessList, accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport type FormatFunc = (value: any) => any;\n\nexport type FormatFuncs = { [ key: string ]: FormatFunc };\n\nexport type Formats = {\n    transaction: FormatFuncs,\n    transactionRequest: FormatFuncs,\n    receipt: FormatFuncs,\n    receiptLog: FormatFuncs,\n    block: FormatFuncs,\n    blockWithTransactions: FormatFuncs,\n    filter: FormatFuncs,\n    filterLog: FormatFuncs,\n};\n\nexport class Formatter {\n    readonly formats: Formats;\n\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n\n    getDefaultFormats(): Formats {\n        const formats: Formats = <Formats>({ });\n\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n\n        const strictData = (v: any) => { return this.data(v, true); };\n\n        formats.transaction = {\n            hash: hash,\n\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n\n            confirmations: Formatter.allowNull(number, null),\n\n            from: address,\n\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n\n            creates: Formatter.allowNull(address, null),\n\n            raw: Formatter.allowNull(data),\n        };\n\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),// @TODO: should this be data?\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n\n            miner: Formatter.allowNull(address),\n            extraData: data,\n\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n\n            topics: Formatter.arrayOf(hash),\n\n            transactionHash: hash,\n            logIndex: number,\n        };\n\n        return formats;\n    }\n\n    accessList(accessList: Array<any>): AccessList {\n        return accessListify(accessList || []);\n    }\n\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number: any): number {\n        if (number === \"0x\") { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    type(number: any): number {\n        if (number === \"0x\" || number == null) { return 0; }\n        return BigNumber.from(number).toNumber();\n    }\n\n    // Strict! Used on input.\n    bigNumber(value: any): BigNumber {\n        return BigNumber.from(value);\n    }\n\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value: any): boolean {\n        if (typeof(value) === \"boolean\") { return value; }\n        if (typeof(value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") { return true; }\n            if (value === \"false\") { return false; }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n\n    hex(value: any, strict?: boolean): string {\n        if (typeof(value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\n            if (isHexString(value)) {\n               return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n\n    data(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n\n    // Requires an address\n    // Strict! Used on input.\n    address(value: any): string {\n        return getAddress(value);\n    }\n\n    callAddress(value: any): string {\n        if (!isHexString(value, 32)) { return null; }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null: address;\n    }\n\n    contractAddress(value: any): string {\n        return getContractAddress(value);\n    }\n\n    // Strict! Used on input.\n    blockTag(blockTag: any): string {\n        if (blockTag == null) { return \"latest\"; }\n\n        if (blockTag === \"earliest\") { return \"0x0\"; }\n\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\": case \"pending\": case \"safe\": case \"finalized\":\n                return blockTag;\n        }\n\n        if (typeof(blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(<number | string>blockTag);\n        }\n\n        throw new Error(\"invalid blockTag\");\n    }\n\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value: any, strict?: boolean): string {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value: any): number {\n        if (value == null) { return null; }\n\n        const v = BigNumber.from(value);\n\n        try {\n            return v.toNumber();\n        } catch (error) { }\n\n       return null;\n    }\n\n    uint256(value: any): string {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n\n    _block(value: any, format: any): Block {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty: value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null: BigNumber.from(difficulty));\n        return result;\n    }\n\n    block(value: any): Block {\n        return this._block(value, this.formats.block);\n    }\n\n    blockWithTransactions(value: any): Block {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n\n    // Strict! Used on input.\n    transactionRequest(value: any): any {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n\n    transactionResponse(transaction: any): TransactionResponse {\n\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n\n        if ((transaction.type === 1 || transaction.type === 2)&& transaction.accessList == null) {\n            transaction.accessList = [ ];\n        }\n\n        const result: TransactionResponse = Formatter.check(this.formats.transaction, transaction);\n\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            result.chainId = chainId;\n\n        } else {\n            let chainId = transaction.networkId;\n\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n\n            if (typeof(chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) { chainId = 0; }\n                chainId = parseInt(chainId);\n            }\n\n            if (typeof(chainId) !== \"number\") { chainId = 0; }\n\n            result.chainId = chainId;\n        }\n\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n\n        return result;\n    }\n\n    transaction(value: any): any {\n        return parseTransaction(value);\n    }\n\n    receiptLog(value: any): any {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n\n    receipt(value: any): TransactionReceipt {\n        const result: TransactionReceipt = Formatter.check(this.formats.receipt, value);\n\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                } else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            } else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n\n        return result;\n    }\n\n    topics(value: any): any {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n\n        } else if (value != null) {\n            return this.hash(value, true);\n        }\n\n        return null;\n    }\n\n    filter(value: any): any {\n        return Formatter.check(this.formats.filter, value);\n    }\n\n    filterLog(value: any): any {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n\n    static check(format: { [ name: string ]: FormatFunc }, object: any): any {\n        const result: any = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) { result[key] = value; }\n            } catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n\n    // if value is null-ish, nullValue is returned\n    static allowNull(format: FormatFunc, nullValue?: any): FormatFunc {\n        return (function(value: any) {\n            if (value == null) { return nullValue; }\n            return format(value);\n        });\n    }\n\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format: FormatFunc, replaceValue: any): FormatFunc {\n        return (function(value: any) {\n            if (!value) { return replaceValue; }\n            return format(value);\n        });\n    }\n\n    // Requires an Array satisfying check\n    static arrayOf(format: FormatFunc): FormatFunc {\n        return (function(array: any): Array<any> {\n            if (!Array.isArray(array)) { throw new Error(\"not an array\"); }\n\n            const result: any = [];\n\n            array.forEach(function(value) {\n                result.push(format(value));\n            });\n\n            return result;\n        });\n    }\n}\n\nexport interface CommunityResourcable {\n    isCommunityResource(): boolean;\n}\n\nexport function isCommunityResourcable(value: any): value is CommunityResourcable {\n    return (value && typeof(value.isCommunityResource) === \"function\");\n}\n\nexport function isCommunityResource(value: any): boolean {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) { return; }\n    throttleMessage = true;\n\n    console.log(\"========= NOTICE =========\")\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n\n","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\nimport {\n    Block, BlockTag, BlockWithTransactions, EventType, Filter, FilterByBlockHash, ForkEvent,\n    Listener, Log, Provider, TransactionReceipt, TransactionRequest, TransactionResponse\n} from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\nimport { arrayify, BytesLike, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork, Network, Networkish } from \"@ethersproject/networks\";\nimport { Deferrable, defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { Transaction } from \"@ethersproject/transactions\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\n\nimport bech32 from \"bech32\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { Formatter } from \"./formatter\";\n\nconst MAX_CCIP_REDIRECTS = 10;\n\n//////////////////////////////\n// Event Serializeing\n\nfunction checkTopic(topic: string): string {\n     if (topic == null) { return \"null\"; }\n     if (hexDataLength(topic) !== 32) {\n         logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n     }\n     return topic.toLowerCase();\n}\n\nfunction serializeTopics(topics: Array<string | Array<string>>): string {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) { topics.pop(); }\n\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n\n            // Only track unique OR-topics\n            const unique: { [ topic: string ]: boolean } = { }\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n\n            return sorted.join(\"|\");\n\n        } else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\n\nfunction deserializeTopics(data: string): Array<string | Array<string>> {\n    if (data === \"\") { return [ ]; }\n\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") { return [ ]; }\n\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null: topic);\n        });\n\n        return ((comps.length === 1) ? comps[0]: comps);\n    });\n}\n\nfunction getEventTag(eventName: EventType): string {\n    if (typeof(eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n\n    } else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n\n    } else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n\n    } else if (eventName && typeof(eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n\n    throw new Error(\"invalid event - \" + eventName);\n}\n\n//////////////////////////////\n// Helper Object\n\nfunction getTime() {\n    return (new Date()).getTime();\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\n//////////////////////////////\n// Provider Object\n\n\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\n\nconst PollableEvents = [ \"block\", \"network\", \"pending\", \"poll\" ];\n\nexport class Event {\n    readonly listener: Listener;\n    readonly once: boolean;\n    readonly tag: string;\n\n    _lastBlockNumber: number\n    _inflight: boolean;\n\n    constructor(tag: string, listener: Listener, once: boolean) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n\n    get event(): EventType {\n        switch (this.type) {\n            case \"tx\":\n               return this.hash;\n            case \"filter\":\n               return this.filter;\n        }\n        return this.tag;\n    }\n\n    get type(): string {\n        return this.tag.split(\":\")[0]\n    }\n\n    get hash(): string {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") { return null; }\n        return comps[1];\n    }\n\n    get filter(): Filter {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") { return null; }\n        const address = comps[1];\n\n        const topics = deserializeTopics(comps[2]);\n        const filter: Filter = { };\n\n        if (topics.length > 0) { filter.topics = topics; }\n        if (address && address !== \"*\") { filter.address = address; }\n\n        return filter;\n    }\n\n    pollable(): boolean {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n\nexport interface EnsResolver {\n\n    // Name this Resolver is associated with\n    readonly name: string;\n\n    // The address of the resolver\n    readonly address: string;\n\n    // Multichain address resolution (also normal address resolution)\n    // See: https://eips.ethereum.org/EIPS/eip-2304\n    getAddress(coinType?: 60): Promise<null | string>\n\n    // Contenthash field\n    // See: https://eips.ethereum.org/EIPS/eip-1577\n    getContentHash(): Promise<null | string>;\n\n    // Storage of text records\n    // See: https://eips.ethereum.org/EIPS/eip-634\n    getText(key: string): Promise<null | string>;\n};\n\nexport interface EnsProvider {\n    resolveName(name: string): Promise<null | string>;\n    lookupAddress(address: string): Promise<null | string>;\n    getResolver(name: string): Promise<null | EnsResolver>;\n}\n\ntype CoinInfo = {\n    symbol: string,\n    ilk?: string,     // General family\n    prefix?: string,  // Bech32 prefix\n    p2pkh?: number,   // Pay-to-Public-Key-Hash Version\n    p2sh?: number,    // Pay-to-Script-Hash Version\n};\n\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos: { [ coinType: string ]: CoinInfo } = {\n    \"0\":   { symbol: \"btc\",  p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\":   { symbol: \"ltc\",  p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\":   { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\":  { symbol: \"eth\",  ilk: \"eth\" },\n    \"61\":  { symbol: \"etc\",  ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\n\nfunction bytes32ify(value: number): string {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data: Uint8Array): string {\n    return Base58.encode(concat([ data, hexDataSlice(sha256(sha256(data)), 0, 4) ]));\n}\n\nexport interface Avatar {\n    url: string;\n    linkage: Array<{ type: string, content: string }>;\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\nfunction _parseString(result: string, start: number): null | string {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    } catch(error) { }\n    return null;\n}\n\nfunction _parseBytes(result: string, start: number): null | string {\n    if (result === \"0x\") { return null; }\n\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\nfunction numPad(value: number): Uint8Array {\n    const result = arrayify(value);\n    if (result.length > 32) { throw new Error(\"internal; should not happen\"); }\n\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\n\nfunction bytesPad(value: Uint8Array): Uint8Array {\n    if ((value.length % 32) === 0) { return value; }\n\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas: Array<BytesLike>) {\n    const result: Array<Uint8Array> = [ ];\n\n    let byteCount = 0;\n\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n\n    return hexConcat(result);\n}\n\nexport class Resolver implements EnsResolver {\n    readonly provider: BaseProvider;\n\n    readonly name: string;\n    readonly address: string;\n\n    readonly _resolvedAddress: null | string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    _supportsEip2544: null | Promise<boolean>;\n\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider: BaseProvider, address: string, name: string, resolvedAddress?: string) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n\n    supportsWildcard(): Promise<boolean> {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return false; }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n\n        return this._supportsEip2544;\n    }\n\n    async _fetch(selector: string, parameters?: string): Promise<null | string> {\n\n        // e.g. keccak256(\"addr(bytes32,uint256)\")\n        const tx = {\n            to: this.address,\n            ccipReadEnabled: true,\n            data: hexConcat([ selector, namehash(this.name), (parameters || \"0x\") ])\n        };\n\n        // Wildcard support; use EIP-2544 to resolve the request\n        let parseBytes = false;\n        if (await this.supportsWildcard()) {\n            parseBytes = true;\n\n            // selector(\"resolve(bytes,bytes)\")\n            tx.data = hexConcat([ \"0x9061b923\", encodeBytes([ dnsEncode(this.name), tx.data ]) ]);\n        }\n\n        try {\n            let result = await this.provider.call(tx);\n            if ((arrayify(result).length % 32) === 4) {\n                logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                    transaction: tx, data: result\n                });\n            }\n            if (parseBytes) { result = _parseBytes(result, 0); }\n            return result;\n        } catch (error) {\n            if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n            throw error;\n        }\n    }\n\n    async _fetchBytes(selector: string, parameters?: string): Promise<null | string> {\n        const result = await this._fetch(selector, parameters);\n        if (result != null) { return _parseBytes(result, 0); }\n        return null;\n    }\n\n    _getAddress(coinType: number, hexBytes: string): string {\n        const coinInfo = coinInfos[String(coinType)];\n\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${ coinType }`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`\n            });\n        }\n\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n\n        const bytes = arrayify(hexBytes);\n\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2pkh ], (\"0x\" + p2pkh[2]) ]));\n                }\n            }\n        }\n\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([ [ coinInfo.p2sh ], (\"0x\" + p2sh[2]) ]));\n                }\n            }\n        }\n\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            } else {\n                version = -1;\n            }\n\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n\n        return null;\n    }\n\n\n    async getAddress(coinType?: number): Promise<string> {\n        if (coinType == null) { coinType = 60; }\n\n        // If Ethereum, use the standard `addr(bytes32)`\n        if (coinType === 60) {\n            try {\n                // keccak256(\"addr(bytes32)\")\n                const result = await this._fetch(\"0x3b3b57de\");\n\n                // No address\n                if (result === \"0x\" || result === HashZero) { return null; }\n\n                return this.provider.formatter.callAddress(result);\n            } catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) { return null; }\n                throw error;\n            }\n        }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const hexBytes = await this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n\n        // No address\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // Compute the address\n        const address = this._getAddress(coinType, hexBytes);\n\n        if (address == null) {\n            logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${ coinType })`,\n                coinType: coinType,\n                data: hexBytes\n            });\n        }\n\n        return address;\n    }\n\n    async getAvatar(): Promise<null | Avatar> {\n        const linkage: Array<{ type: string, content: string }> = [ { type: \"name\", content: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) { return null; }\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                        linkage.push({ type: \"url\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"data\":\n                        linkage.push({ type: \"data\", content: avatar });\n                        return { linkage, url: avatar };\n\n                    case \"ipfs\":\n                        linkage.push({ type: \"ipfs\", content: avatar });\n                        return { linkage, url: getIpfsLink(avatar) };\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"0xc87b56dd\": \"0x0e89341c\";\n                        linkage.push({ type: scheme, content: avatar });\n\n                        // The owner of this name\n                        const owner = (this._resolvedAddress || await this.getAddress());\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) { return null; }\n\n                        const addr = await this.provider.formatter.address(comps[0]);\n                        const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            // ownerOf(uint256 tokenId)\n                            const tokenOwner = this.provider.formatter.callAddress(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x6352211e\", tokenId ])\n                            }));\n                            if (owner !== tokenOwner) { return null; }\n                            linkage.push({ type: \"owner\", content: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            // balanceOf(address owner, uint256 tokenId)\n                            const balance = BigNumber.from(await this.provider.call({\n                                to: addr, data: hexConcat([ \"0x00fdd58e\", hexZeroPad(owner, 32), tokenId ])\n                            }));\n                            if (balance.isZero()) { return null; }\n                            linkage.push({ type: \"balance\", content: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        const tx = {\n                            to: this.provider.formatter.address(comps[0]),\n                            data: hexConcat([ selector, tokenId ])\n                        };\n\n                        let metadataUrl = _parseString(await this.provider.call(tx), 0);\n                        if (metadataUrl == null) { return null; }\n                        linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n\n                        linkage.push({ type: \"metadata-url\", content: metadataUrl });\n\n                        // Get the token metadata\n                        const metadata = await fetchJson(metadataUrl);\n                        if (!metadata) { return null; }\n                        linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") { return null; }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) { return null; }\n\n                            linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", content: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return null;\n    }\n\n    async getContentHash(): Promise<string> {\n\n        // keccak256(\"contenthash()\")\n        const hexBytes = await this._fetchBytes(\"0xbc1c58d1\");\n\n        // No contenthash\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: DAG-PB)\n        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const length = parseInt(ipfs[3], 16);\n            if (ipfs[4].length === length * 2) {\n                return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n            }\n        }\n\n        // IPNS (CID: 1, Type: libp2p-key)\n        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipns) {\n            const length = parseInt(ipns[3], 16);\n            if (ipns[4].length === length * 2) {\n                return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm) {\n            if (swarm[1].length === (32 * 2)) {\n                return \"bzz:/\\/\" + swarm[1]\n            }\n        }\n\n        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n        if (skynet) {\n            if (skynet[1].length === (34 * 2)) {\n                // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                const urlSafe: Record<string, string> = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                return \"sia:/\\/\" + hash;\n            }\n        }\n\n        return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"getContentHash()\",\n            data: hexBytes\n        });\n    }\n\n    async getText(key: string): Promise<string> {\n\n        // The key encoded as parameter to fetchBytes\n        let keyBytes = toUtf8Bytes(key);\n\n        // The nodehash consumes the first slot, so the string pointer targets\n        // offset 64, with the length at offset 64 and data starting at offset 96\n        keyBytes = concat([ bytes32ify(64), bytes32ify(keyBytes.length), keyBytes ]);\n\n        // Pad to word-size (32 bytes)\n        if ((keyBytes.length % 32) !== 0) {\n            keyBytes = concat([ keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32)) ])\n        }\n\n        const hexBytes = await this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n        if (hexBytes == null || hexBytes === \"0x\") { return null; }\n\n        return toUtf8String(hexBytes);\n    }\n}\n\nlet defaultFormatter: Formatter = null;\n\nlet nextPollId = 1;\n\nexport class BaseProvider extends Provider implements EnsProvider {\n    _networkPromise: Promise<Network>;\n    _network: Network;\n\n    _events: Array<Event>;\n\n    formatter: Formatter;\n\n    // To help mitigate the eventually consistent nature of the blockchain\n    // we keep a mapping of events we emit. If we emit an event X, we expect\n    // that a user should be able to query for that event in the callback,\n    // if the node returns null, we stall the response until we get back a\n    // meaningful value, since we may be hitting a re-org, or a node that\n    // has not indexed the event yet.\n    // Events:\n    //   - t:{hash}    - Transaction hash\n    //   - b:{hash}    - BlockHash\n    //   - block       - The most recent emitted block\n    _emitted: { [ eventName: string ]: number | \"pending\" };\n\n    _pollingInterval: number;\n    _poller: NodeJS.Timer;\n    _bootstrapPoll: NodeJS.Timer;\n\n    _lastBlockNumber: number;\n    _maxFilterBlockRange: number;\n\n    _fastBlockNumber: number;\n    _fastBlockNumberPromise: Promise<number>;\n    _fastQueryDate: number;\n\n    _maxInternalBlockNumber: number;\n    _internalBlockNumber: Promise<{ blockNumber: number, reqTime: number, respTime: number }>;\n\n    readonly anyNetwork: boolean;\n\n    disableCcipRead: boolean;\n\n\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n\n    constructor(network: Networkish | Promise<Network>) {\n        super();\n\n        // Events being listened to\n        this._events = [];\n\n        this._emitted = { block: -2 };\n\n        this.disableCcipRead = false;\n\n        this.formatter = new.target.getFormatter();\n\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) { network = this.detectNetwork(); }\n\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n\n        } else {\n            const knownNetwork = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n\n            } else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n\n        this._maxInternalBlockNumber = -1024;\n\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n\n        this._pollingInterval = 4000;\n\n        this._fastQueryDate = 0;\n    }\n\n    async _ready(): Promise<Network> {\n        if (this._network == null) {\n            let network: Network = null;\n            if (this._networkPromise) {\n                try {\n                    network = await this._networkPromise;\n                } catch (error) { }\n            }\n\n            // Try the Provider's network detection (this MUST throw if it cannot)\n            if (network == null) {\n                network = await this.detectNetwork();\n            }\n\n            // This should never happen; every Provider sub-class should have\n            // suggested a network by here (or have thrown).\n            if (!network) {\n                logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, { });\n            }\n\n            // Possible this call stacked so do not call defineReadOnly again\n            if (this._network == null) {\n                if (this.anyNetwork) {\n                    this._network = network;\n                } else {\n                    defineReadOnly(this, \"_network\", network);\n                }\n                this.emit(\"network\", network, null);\n            }\n        }\n\n        return this._network;\n    }\n\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready(): Promise<Network> {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter(): Formatter {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network: Networkish): Network {\n        return getNetwork((network == null) ? \"homestead\": network);\n    }\n\n    async ccipReadFetch(tx: Transaction, calldata: string, urls: Array<string>): Promise<null | string> {\n        if (this.disableCcipRead || urls.length === 0) { return null; }\n\n        const sender = tx.to.toLowerCase();\n        const data = calldata.toLowerCase();\n\n        const errorMessages: Array<string> = [ ];\n\n        for (let i = 0; i < urls.length; i++) {\n            const url = urls[i];\n\n            // URL expansion\n            const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n\n            // If no {data} is present, use POST; otherwise GET\n            const json: string | null = (url.indexOf(\"{data}\") >= 0) ? null: JSON.stringify({ data, sender });\n\n            const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                value.status = response.statusCode;\n                return value;\n            });\n\n            if (result.data) { return result.data; }\n\n            const errorMessage = (result.message || \"unknown error\");\n\n            // 4xx indicates the result is not present; stop\n            if (result.status >= 400 && result.status < 500) {\n                return logger.throwError(`response not found during CCIP fetch: ${ errorMessage }`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n            }\n\n            // 5xx indicates server issue; try the next url\n            errorMessages.push(errorMessage);\n        }\n\n        return logger.throwError(`error encountered during CCIP fetch: ${ errorMessages.map((m) => JSON.stringify(m)).join(\", \") }`, Logger.errors.SERVER_ERROR, {\n            urls, errorMessages\n        });\n    }\n\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    async _getInternalBlockNumber(maxAge: number): Promise<number> {\n        await this._ready();\n\n        // Allowing stale data up to maxAge old\n        if (maxAge > 0) {\n\n            // While there are pending internal block requests...\n            while (this._internalBlockNumber) {\n\n                // ...\"remember\" which fetch we started with\n                const internalBlockNumber = this._internalBlockNumber;\n\n                try {\n                    // Check the result is not too stale\n                    const result = await internalBlockNumber;\n                    if ((getTime() - result.respTime) <= maxAge) {\n                        return result.blockNumber;\n                    }\n\n                    // Too old; fetch a new value\n                    break;\n\n                } catch(error) {\n\n                    // The fetch rejected; if we are the first to get the\n                    // rejection, drop through so we replace it with a new\n                    // fetch; all others blocked will then get that fetch\n                    // which won't match the one they \"remembered\" and loop\n                    if (this._internalBlockNumber === internalBlockNumber) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        const reqTime = getTime();\n\n        const checkInternalBlockNumber = resolveProperties({\n            blockNumber: this.perform(\"getBlockNumber\", { }),\n            networkError: this.getNetwork().then((network) => (null), (error) => (error))\n        }).then(({ blockNumber, networkError }) => {\n            if (networkError) {\n                // Unremember this bad internal block number\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n                throw networkError;\n            }\n\n            const respTime = getTime();\n\n            blockNumber = BigNumber.from(blockNumber).toNumber();\n            if (blockNumber < this._maxInternalBlockNumber) { blockNumber = this._maxInternalBlockNumber; }\n\n            this._maxInternalBlockNumber = blockNumber;\n            this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n            return { blockNumber, reqTime, respTime };\n        });\n\n        this._internalBlockNumber = checkInternalBlockNumber;\n\n        // Swallow unhandled exceptions; if needed they are handled else where\n        checkInternalBlockNumber.catch((error) => {\n            // Don't null the dead (rejected) fetch, if it has already been updated\n            if (this._internalBlockNumber === checkInternalBlockNumber) {\n                this._internalBlockNumber = null;\n            }\n        });\n\n        return (await checkInternalBlockNumber).blockNumber;\n    }\n\n    async poll(): Promise<void> {\n        const pollId = nextPollId++;\n\n        // Track all running promises, so we can trigger a post-poll once they are complete\n        const runners: Array<Promise<void>> = [];\n\n        let blockNumber: number = null;\n        try {\n            blockNumber = await this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n        } catch (error) {\n            this.emit(\"error\", error);\n            return;\n        }\n        this._setFastBlockNumber(blockNumber);\n\n        // Emit a poll event after we have the latest (fast) block number\n        this.emit(\"poll\", pollId, blockNumber);\n\n        // If the block has not changed, meh.\n        if (blockNumber === this._lastBlockNumber) {\n            this.emit(\"didPoll\", pollId);\n            return;\n        }\n\n        // First polling cycle, trigger a \"block\" events\n        if (this._emitted.block === -2) {\n            this._emitted.block = blockNumber - 1;\n        }\n\n        if (Math.abs((<number>(this._emitted.block)) - blockNumber) > 1000) {\n            logger.warn(`network block skew detected; skipping block events (emitted=${ this._emitted.block } blockNumber${ blockNumber })`);\n            this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                blockNumber: blockNumber,\n                event: \"blockSkew\",\n                previousBlockNumber: this._emitted.block\n            }));\n            this.emit(\"block\", blockNumber);\n\n        } else {\n            // Notify all listener for each block that has passed\n            for (let i = (<number>this._emitted.block) + 1; i <= blockNumber; i++) {\n                this.emit(\"block\", i);\n            }\n        }\n\n        // The emitted block was updated, check for obsolete events\n        if ((<number>this._emitted.block) !== blockNumber) {\n            this._emitted.block = blockNumber;\n\n            Object.keys(this._emitted).forEach((key) => {\n                // The block event does not expire\n                if (key === \"block\") { return; }\n\n                // The block we were at when we emitted this event\n                const eventBlockNumber = this._emitted[key];\n\n                // We cannot garbage collect pending transactions or blocks here\n                // They should be garbage collected by the Provider when setting\n                // \"pending\" events\n                if (eventBlockNumber === \"pending\") { return; }\n\n                // Evict any transaction hashes or block hashes over 12 blocks\n                // old, since they should not return null anyways\n                if (blockNumber - eventBlockNumber > 12) {\n                    delete this._emitted[key];\n                }\n            });\n        }\n\n        // First polling cycle\n        if (this._lastBlockNumber === -2) {\n            this._lastBlockNumber = blockNumber - 1;\n        }\n        // Find all transaction hashes we are waiting on\n        this._events.forEach((event) => {\n            switch (event.type) {\n                case \"tx\": {\n                    const hash = event.hash;\n                    let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt || receipt.blockNumber == null) { return null; }\n                        this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                        this.emit(hash, receipt);\n                        return null;\n                    }).catch((error: Error) => { this.emit(\"error\", error); });\n\n                    runners.push(runner);\n\n                    break;\n                }\n\n                case \"filter\": {\n                    // We only allow a single getLogs to be in-flight at a time\n                    if (!event._inflight) {\n                        event._inflight = true;\n\n                        // This is the first filter for this event, so we want to\n                        // restrict events to events that happened no earlier than now\n                        if (event._lastBlockNumber === -2) {\n                            event._lastBlockNumber = blockNumber - 1;\n                        }\n\n                        // Filter from the last *known* event; due to load-balancing\n                        // and some nodes returning updated block numbers before\n                        // indexing events, a logs result with 0 entries cannot be\n                        // trusted and we must retry a range which includes it again\n                        const filter = event.filter;\n                        filter.fromBlock = event._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n\n                        // Prevent fitler ranges from growing too wild, since it is quite\n                        // likely there just haven't been any events to move the lastBlockNumber.\n                        const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                        if (minFromBlock > filter.fromBlock) { filter.fromBlock = minFromBlock; }\n\n                        if (filter.fromBlock < 0) { filter.fromBlock = 0; }\n\n                        const runner = this.getLogs(filter).then((logs) => {\n                            // Allow the next getLogs\n                            event._inflight = false;\n\n                            if (logs.length === 0) { return; }\n\n                            logs.forEach((log: Log) => {\n                                // Only when we get an event for a given block number\n                                // can we trust the events are indexed\n                                if (log.blockNumber > event._lastBlockNumber) {\n                                    event._lastBlockNumber = log.blockNumber;\n                                }\n\n                                // Make sure we stall requests to fetch blocks and txs\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n\n                                this.emit(filter, log);\n                            });\n                        }).catch((error: Error) => {\n                            this.emit(\"error\", error);\n\n                            // Allow another getLogs (the range was not updated)\n                            event._inflight = false;\n                        });\n                        runners.push(runner);\n                    }\n\n                    break;\n                }\n            }\n        });\n\n        this._lastBlockNumber = blockNumber;\n\n        // Once all events for this loop have been processed, emit \"didPoll\"\n        Promise.all(runners).then(() => {\n            this.emit(\"didPoll\", pollId);\n        }).catch((error) => { this.emit(\"error\", error); });\n\n        return;\n    }\n\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber: number): void {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) { this.poll(); }\n    }\n\n    get network(): Network {\n        return this._network;\n    }\n\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    async detectNetwork(): Promise<Network> {\n        return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"provider.detectNetwork\"\n        });\n    }\n\n    async getNetwork(): Promise<Network> {\n        const network = await this._ready();\n\n        // Make sure we are still connected to the same network; this is\n        // only an external call for backends which can have the underlying\n        // network change spontaneously\n        const currentNetwork = await this.detectNetwork();\n        if (network.chainId !== currentNetwork.chainId) {\n\n            // We are allowing network changes, things can get complex fast;\n            // make sure you know what you are doing if you use \"any\"\n            if (this.anyNetwork) {\n                this._network = currentNetwork;\n\n                // Reset all internal block number guards and caches\n                this._lastBlockNumber = -2;\n                this._fastBlockNumber = null;\n                this._fastBlockNumberPromise = null;\n                this._fastQueryDate = 0;\n                this._emitted.block = -2;\n                this._maxInternalBlockNumber = -1024;\n                this._internalBlockNumber = null;\n\n                // The \"network\" event MUST happen before this method resolves\n                // so any events have a chance to unregister, so we stall an\n                // additional event loop before returning from /this/ call\n                this.emit(\"network\", currentNetwork, network);\n                await stall(0);\n\n                return this._network;\n            }\n\n            const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                event: \"changed\",\n                network: network,\n                detectedNetwork: currentNetwork\n            });\n\n            this.emit(\"error\", error);\n            throw error;\n        }\n\n        return network;\n    }\n\n    get blockNumber(): number {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber: -1;\n    }\n\n    get polling(): boolean {\n        return (this._poller != null);\n    }\n\n    set polling(value: boolean) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) { this.poll(); }\n\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n\n        } else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n\n    get pollingInterval(): number {\n        return this._pollingInterval;\n    }\n\n    set pollingInterval(value: number) {\n        if (typeof(value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n\n        this._pollingInterval = value;\n\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n\n    _getFastBlockNumber(): Promise<number> {\n        const now = getTime();\n\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n\n        return this._fastBlockNumberPromise;\n    }\n\n    _setFastBlockNumber(blockNumber: number): void {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) { return; }\n\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n\n    async waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt> {\n        return this._waitForTransaction(transactionHash, (confirmations == null) ? 1: confirmations, timeout || 0, null);\n    }\n\n    async _waitForTransaction(transactionHash: string, confirmations: number, timeout: number, replaceable: { data: string, from: string, nonce: number, to: string, value: BigNumber, startBlock: number }): Promise<TransactionReceipt> {\n        const receipt = await this.getTransactionReceipt(transactionHash);\n\n        // Receipt is already good\n        if ((receipt ? receipt.confirmations: 0) >= confirmations) { return receipt; }\n\n        // Poll until the receipt is good...\n        return new Promise((resolve, reject) => {\n            const cancelFuncs: Array<() => void> = [];\n\n            let done = false;\n            const alreadyDone = function() {\n                if (done) { return true; }\n                done = true;\n                cancelFuncs.forEach((func) => { func(); });\n                return false;\n            };\n\n            const minedHandler = (receipt: TransactionReceipt) => {\n                if (receipt.confirmations < confirmations) { return; }\n                if (alreadyDone()) { return; }\n                resolve(receipt);\n            }\n            this.on(transactionHash, minedHandler);\n            cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n\n            if (replaceable) {\n                let lastBlockNumber = replaceable.startBlock;\n                let scannedBlock: number = null;\n                const replaceHandler = async (blockNumber: number) => {\n                    if (done) { return; }\n\n                    // Wait 1 second; this is only used in the case of a fault, so\n                    // we will trade off a little bit of latency for more consistent\n                    // results and fewer JSON-RPC calls\n                    await stall(1000);\n\n                    this.getTransactionCount(replaceable.from).then(async (nonce) => {\n                        if (done) { return; }\n\n                        if (nonce <= replaceable.nonce) {\n                            lastBlockNumber = blockNumber;\n\n                        } else {\n                            // First check if the transaction was mined\n                            {\n                                const mined = await this.getTransaction(transactionHash);\n                                if (mined && mined.blockNumber != null) { return; }\n                            }\n\n                            // First time scanning. We start a little earlier for some\n                            // wiggle room here to handle the eventually consistent nature\n                            // of blockchain (e.g. the getTransactionCount was for a\n                            // different block)\n                            if (scannedBlock == null) {\n                                scannedBlock = lastBlockNumber - 3;\n                                if (scannedBlock < replaceable.startBlock) {\n                                    scannedBlock = replaceable.startBlock;\n                                }\n                            }\n\n                            while (scannedBlock <= blockNumber) {\n                                if (done) { return; }\n\n                                const block = await this.getBlockWithTransactions(scannedBlock);\n                                for (let ti = 0; ti < block.transactions.length; ti++) {\n                                    const tx = block.transactions[ti];\n\n                                    // Successfully mined!\n                                    if (tx.hash === transactionHash) { return; }\n\n                                    // Matches our transaction from and nonce; its a replacement\n                                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                        if (done) { return; }\n\n                                        // Get the receipt of the replacement\n                                        const receipt = await this.waitForTransaction(tx.hash, confirmations);\n\n                                        // Already resolved or rejected (prolly a timeout)\n                                        if (alreadyDone()) { return; }\n\n                                        // The reason we were replaced\n                                        let reason = \"replaced\";\n                                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                            reason = \"repriced\";\n                                        } else  if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                            reason = \"cancelled\"\n                                        }\n\n                                        // Explain why we were replaced\n                                        reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                            reason,\n                                            replacement: this._wrapTransaction(tx),\n                                            hash: transactionHash,\n                                            receipt\n                                        }));\n\n                                        return;\n                                    }\n                                }\n                                scannedBlock++;\n                            }\n                        }\n\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n\n                    }, (error) => {\n                        if (done) { return; }\n                        this.once(\"block\", replaceHandler);\n                    });\n                };\n\n                if (done) { return; }\n                this.once(\"block\", replaceHandler);\n\n                cancelFuncs.push(() => {\n                    this.removeListener(\"block\", replaceHandler);\n                });\n            }\n\n            if (typeof(timeout) === \"number\" && timeout > 0) {\n                const timer = setTimeout(() => {\n                    if (alreadyDone()) { return; }\n                    reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                }, timeout);\n                if (timer.unref) { timer.unref(); }\n\n                cancelFuncs.push(() => { clearTimeout(timer); });\n            }\n        });\n    }\n\n    async getBlockNumber(): Promise<number> {\n        return this._getInternalBlockNumber(0);\n    }\n\n    async getGasPrice(): Promise<BigNumber> {\n        await this.getNetwork();\n\n        const result = await this.perform(\"getGasPrice\", { });\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getGasPrice\",\n                result, error\n            });\n        }\n    }\n\n    async getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getBalance\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getBalance\",\n                params, result, error\n            });\n        }\n    }\n\n    async getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getTransactionCount\", params);\n        try {\n            return BigNumber.from(result).toNumber();\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getTransactionCount\",\n                params, result, error\n            });\n        }\n    }\n\n    async getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag)\n        });\n\n        const result = await this.perform(\"getCode\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getCode\",\n                params, result, error\n            });\n        }\n    }\n\n    async getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            address: this._getAddress(addressOrName),\n            blockTag: this._getBlockTag(blockTag),\n            position: Promise.resolve(position).then((p) => hexValue(p))\n        });\n        const result = await this.perform(\"getStorageAt\", params);\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"getStorageAt\",\n                params, result, error\n            });\n        }\n    }\n\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx: Transaction, hash?: string, startBlock?: number): TransactionResponse {\n        if (hash != null && hexDataLength(hash) !== 32) { throw new Error(\"invalid response - sendTransaction\"); }\n\n        const result = <TransactionResponse>tx;\n\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n\n        result.wait = async (confirms?: number, timeout?: number) => {\n            if (confirms == null) { confirms = 1; }\n            if (timeout == null) { timeout = 0; }\n\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n\n            const receipt = await this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) { return null; }\n\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        };\n\n        return result;\n    }\n\n    async sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        const hexTx = await Promise.resolve(signedTransaction).then(t => hexlify(t));\n        const tx = this.formatter.transaction(signedTransaction);\n        if (tx.confirmations == null) { tx.confirmations = 0; }\n        const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n        try {\n            const hash = await this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n            return this._wrapTransaction(tx, hash, blockNumber);\n        } catch (error) {\n            (<any>error).transaction = tx;\n            (<any>error).transactionHash = tx.hash;\n            throw error;\n        }\n    }\n\n    async _getTransactionRequest(transaction: Deferrable<TransactionRequest>): Promise<Transaction> {\n        const values: any = await transaction;\n\n        const tx: any = { };\n\n        [\"from\", \"to\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v): null))\n        });\n\n        [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v): null));\n        });\n\n        [\"type\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v: null));\n        });\n\n        if (values.accessList) {\n            tx.accessList = this.formatter.accessList(values.accessList);\n        }\n\n        [\"data\"].forEach((key) => {\n            if (values[key] == null) { return; }\n            tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v): null));\n        });\n\n        return this.formatter.transactionRequest(await resolveProperties(tx));\n    }\n\n    async _getFilter(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Filter | FilterByBlockHash> {\n        filter = await filter;\n\n        const result: any = { };\n\n        if (filter.address != null) {\n            result.address = this._getAddress(filter.address);\n        }\n\n        [\"blockHash\", \"topics\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = (<any>filter)[key];\n        });\n\n        [\"fromBlock\", \"toBlock\"].forEach((key) => {\n            if ((<any>filter)[key] == null) { return; }\n            result[key] = this._getBlockTag((<any>filter)[key]);\n        });\n\n        return this.formatter.filter(await resolveProperties(result));\n    }\n\n    async _call(transaction: TransactionRequest, blockTag: BlockTag, attempt: number): Promise<string> {\n        if (attempt >= MAX_CCIP_REDIRECTS) {\n            logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                redirects: attempt, transaction\n            });\n        }\n\n        const txSender = transaction.to;\n\n        const result = await this.perform(\"call\", { transaction, blockTag });\n\n        // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n        if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n            try {\n                const data = hexDataSlice(result, 4);\n\n                // Check the sender of the OffchainLookup matches the transaction\n                const sender = hexDataSlice(data, 0, 32);\n                if (!BigNumber.from(sender).eq(txSender)) {\n                    logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                // Read the URLs from the response\n                const urls: Array<string> = [];\n                const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                const urlsData = hexDataSlice(data, urlsOffset + 32);\n                for (let u = 0; u < urlsLength; u++) {\n                    const url = _parseString(urlsData, u * 32);\n                    if (url == null) {\n                        logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    urls.push(url);\n                }\n\n                // Get the CCIP calldata to forward\n                const calldata = _parseBytes(data, 64);\n\n                // Get the callbackSelector (bytes4)\n                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                    logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n                const callbackSelector = hexDataSlice(data, 96, 100);\n\n                // Get the extra data to send back to the contract as context\n                const extraData = _parseBytes(data, 128);\n\n                const ccipResult = await this.ccipReadFetch(<Transaction>transaction, calldata, urls);\n                if (ccipResult == null) {\n                    logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                        name: \"OffchainLookup\",\n                        signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                        transaction, data: result\n                    });\n                }\n\n                const tx = {\n                    to: txSender,\n                    data: hexConcat([ callbackSelector, encodeBytes([ ccipResult, extraData ]) ])\n                };\n\n                return this._call(tx, blockTag, attempt + 1);\n\n            } catch (error) {\n                if (error.code === Logger.errors.SERVER_ERROR) { throw error; }\n            }\n        }\n\n        try {\n            return hexlify(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"call\",\n                params: { transaction, blockTag }, result, error\n            });\n        }\n\n    }\n\n    async call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string> {\n        await this.getNetwork();\n        const resolved = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction),\n            blockTag: this._getBlockTag(blockTag),\n            ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n        });\n        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0: -1);\n    }\n\n    async estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber> {\n        await this.getNetwork();\n        const params = await resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n\n        const result = await this.perform(\"estimateGas\", params);\n        try {\n            return BigNumber.from(result);\n        } catch (error) {\n            return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                method: \"estimateGas\",\n                params, result, error\n            });\n        }\n    }\n\n    async _getAddress(addressOrName: string | Promise<string>): Promise<string> {\n        addressOrName = await addressOrName;\n        if (typeof(addressOrName) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n        }\n\n        const address = await this.resolveName(addressOrName);\n        if (address == null) {\n            logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `resolveName(${ JSON.stringify(addressOrName) })`\n            });\n        }\n        return address;\n    }\n\n    async _getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>, includeTransactions?: boolean): Promise<Block | BlockWithTransactions> {\n        await this.getNetwork();\n\n        blockHashOrBlockTag = await blockHashOrBlockTag;\n\n        // If blockTag is a number (not \"latest\", etc), this is the block number\n        let blockNumber = -128;\n\n        const params: { [key: string]: any } = {\n            includeTransactions: !!includeTransactions\n        };\n\n        if (isHexString(blockHashOrBlockTag, 32)) {\n            params.blockHash = blockHashOrBlockTag;\n        } else {\n            try {\n                params.blockTag = await this._getBlockTag(blockHashOrBlockTag);\n                if (isHexString(params.blockTag)) {\n                    blockNumber = parseInt(params.blockTag.substring(2), 16);\n                }\n            } catch (error) {\n                logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n            }\n        }\n\n        return poll(async () => {\n            const block = await this.perform(\"getBlock\", params);\n\n            // Block was not found\n            if (block == null) {\n\n                // For blockhashes, if we didn't say it existed, that blockhash may\n                // not exist. If we did see it though, perhaps from a log, we know\n                // it exists, and this node is just not caught up yet.\n                if (params.blockHash != null) {\n                    if (this._emitted[\"b:\" + params.blockHash] == null) { return null; }\n                }\n\n                // For block tags, if we are asking for a future block, we return null\n                if (params.blockTag != null) {\n                    if (blockNumber > this._emitted.block) { return null; }\n                }\n\n                // Retry on the next block\n                return undefined;\n            }\n\n            // Add transactions\n            if (includeTransactions) {\n                let blockNumber: number = null;\n                for (let i = 0; i < block.transactions.length; i++) {\n                    const tx = block.transactions[i];\n                    if (tx.blockNumber == null) {\n                        tx.confirmations = 0;\n\n                    } else if (tx.confirmations == null) {\n                        if (blockNumber == null) {\n                            blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                        }\n\n                        // Add the confirmations using the fast block number (pessimistic)\n                        let confirmations = (blockNumber - tx.blockNumber) + 1;\n                        if (confirmations <= 0) { confirmations = 1; }\n                        tx.confirmations = confirmations;\n                    }\n                }\n\n                const blockWithTxs: any = this.formatter.blockWithTransactions(block);\n                blockWithTxs.transactions = blockWithTxs.transactions.map((tx: TransactionResponse) => this._wrapTransaction(tx));\n                return blockWithTxs;\n            }\n\n            return this.formatter.block(block);\n\n        }, { oncePoll: this });\n    }\n\n    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block> {\n        return <Promise<Block>>(this._getBlock(blockHashOrBlockTag, false));\n    }\n\n    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions> {\n        return <Promise<BlockWithTransactions>>(this._getBlock(blockHashOrBlockTag, true));\n    }\n\n    async getTransaction(transactionHash: string | Promise<string>): Promise<TransactionResponse> {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransaction\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            const tx = this.formatter.transactionResponse(result);\n\n            if (tx.blockNumber == null) {\n                tx.confirmations = 0;\n\n            } else if (tx.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - tx.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                tx.confirmations = confirmations;\n            }\n\n            return this._wrapTransaction(tx);\n        }, { oncePoll: this });\n    }\n\n    async getTransactionReceipt(transactionHash: string | Promise<string>): Promise<TransactionReceipt> {\n        await this.getNetwork();\n\n        transactionHash = await transactionHash;\n\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\n        return poll(async () => {\n            const result = await this.perform(\"getTransactionReceipt\", params);\n\n            if (result == null) {\n                if (this._emitted[\"t:\" + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n\n            // \"geth-etc\" returns receipts before they are ready\n            if (result.blockHash == null) { return undefined; }\n\n            const receipt = this.formatter.receipt(result);\n\n            if (receipt.blockNumber == null) {\n                receipt.confirmations = 0;\n\n            } else if (receipt.confirmations == null) {\n                const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n\n                // Add the confirmations using the fast block number (pessimistic)\n                let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                if (confirmations <= 0) { confirmations = 1; }\n                receipt.confirmations = confirmations;\n            }\n\n            return receipt;\n        }, { oncePoll: this });\n    }\n\n    async getLogs(filter: Filter | FilterByBlockHash | Promise<Filter | FilterByBlockHash>): Promise<Array<Log>> {\n        await this.getNetwork();\n        const params = await resolveProperties({ filter: this._getFilter(filter) });\n        const logs: Array<Log> = await this.perform(\"getLogs\", params);\n        logs.forEach((log) => {\n            if (log.removed == null) { log.removed = false; }\n        });\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n\n    async getEtherPrice(): Promise<number> {\n        await this.getNetwork();\n        return this.perform(\"getEtherPrice\", { });\n    }\n\n    async _getBlockTag(blockTag: BlockTag | Promise<BlockTag>): Promise<BlockTag> {\n        blockTag = await blockTag;\n\n        if (typeof(blockTag) === \"number\" && blockTag < 0) {\n            if (blockTag % 1) {\n                logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n            }\n\n            let blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            blockNumber += blockTag;\n            if (blockNumber < 0) { blockNumber = 0; }\n            return this.formatter.blockTag(blockNumber)\n        }\n\n        return this.formatter.blockTag(blockTag);\n    }\n\n\n    async getResolver(name: string): Promise<null | Resolver> {\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcard resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await this._getResolver(currentName, \"getResolver\");\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new Resolver(this, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n\n    }\n\n    async _getResolver(name: string, operation?: string): Promise<string> {\n        if (operation == null) { operation = \"ENS\"; }\n\n        const network = await this.getNetwork();\n\n        // No ENS...\n        if (!network.ensAddress) {\n            logger.throwError(\n                \"network does not support ENS\",\n                Logger.errors.UNSUPPORTED_OPERATION,\n                { operation, network: network.name }\n            );\n        }\n\n        try {\n            // keccak256(\"resolver(bytes32)\")\n            const addrData = await this.call({\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            });\n            return this.formatter.callAddress(addrData);\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32)\n        }\n\n        return null;\n    }\n\n    async resolveName(name: string | Promise<string>): Promise<null | string> {\n        name = await name;\n\n        // If it is already an address, nothing to resolve\n        try {\n            return Promise.resolve(this.formatter.address(name));\n        } catch (error) {\n            // If is is a hexstring, the address is bad (See #694)\n            if (isHexString(name)) { throw error; }\n        }\n\n        if (typeof(name) !== \"string\") {\n            logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n        }\n\n        // Get the addr from the resolver\n        const resolver = await this.getResolver(name);\n        if (!resolver) { return null; }\n\n        return await resolver.getAddress();\n    }\n\n    async lookupAddress(address: string | Promise<string>): Promise<null | string> {\n        address = await address;\n        address = this.formatter.address(address);\n\n        const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n        const resolverAddr = await this._getResolver(node, \"lookupAddress\");\n        if (resolverAddr == null) { return null; }\n\n        // keccak(\"name(bytes32)\")\n        const name = _parseString(await this.call({\n            to: resolverAddr,\n            data: (\"0x691f3431\" + namehash(node).substring(2))\n        }), 0);\n\n        const addr = await this.resolveName(name);\n        if (addr != address) { return null; }\n\n        return name;\n    }\n\n    async getAvatar(nameOrAddress: string): Promise<null | string> {\n        let resolver: Resolver = null;\n        if (isHexString(nameOrAddress)) {\n            // Address; reverse lookup\n            const address = this.formatter.address(nameOrAddress);\n\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n\n            const resolverAddress = await this._getResolver(node, \"getAvatar\");\n            if (!resolverAddress) { return null; }\n\n            // Try resolving the avatar against the addr.reverse resolver\n            resolver = new Resolver(this, resolverAddress, node);\n            try {\n                const avatar = await resolver.getAvatar();\n                if (avatar) { return avatar.url; }\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n            }\n\n            // Try getting the name and performing forward lookup; allowing wildcards\n            try {\n                // keccak(\"name(bytes32)\")\n                const name = _parseString(await this.call({\n                    to: resolverAddress,\n                    data: (\"0x691f3431\" + namehash(node).substring(2))\n                }), 0);\n                resolver = await this.getResolver(name);\n            } catch (error) {\n                if (error.code !== Logger.errors.CALL_EXCEPTION) { throw error; }\n                return null;\n            }\n\n        } else {\n            // ENS name; forward lookup with wildcard\n            resolver = await this.getResolver(nameOrAddress);\n            if (!resolver) { return null; }\n        }\n\n        const avatar = await resolver.getAvatar();\n        if (avatar == null) { return null; }\n\n        return avatar.url;\n    }\n\n    perform(method: string, params: any): Promise<any> {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n\n    _startEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _stopEvent(event: Event): void {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n\n    _addEventListener(eventName: EventType, listener: Listener, once: boolean): this {\n        const event = new Event(getEventTag(eventName), listener, once)\n        this._events.push(event);\n        this._startEvent(event);\n\n        return this;\n    }\n\n    on(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, false);\n    }\n\n    once(eventName: EventType, listener: Listener): this {\n        return this._addEventListener(eventName, listener, true);\n    }\n\n\n    emit(eventName: EventType, ...args: Array<any>): boolean {\n        let result = false;\n\n        let stopped: Array<Event> = [ ];\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) { return true; }\n\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n\n            result = true;\n\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n\n            return true;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return result;\n    }\n\n    listenerCount(eventName?: EventType): number {\n        if (!eventName) { return this._events.length; }\n\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n\n    listeners(eventName?: EventType): Array<Listener> {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n\n    off(eventName: EventType, listener?: Listener): this {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n\n        const stopped: Array<Event> = [ ];\n\n        let found = false;\n\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) { return true; }\n            if (found) { return true; }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n\n    removeAllListeners(eventName?: EventType): this {\n        let stopped: Array<Event> = [ ];\n        if (eventName == null) {\n            stopped = this._events;\n\n            this._events = [ ];\n        } else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) { return true; }\n                stopped.push(event);\n                return false;\n            });\n        }\n\n        stopped.forEach((event) => { this._stopEvent(event); });\n\n        return this;\n    }\n}\n","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n\n","\"use strict\";\n\n// See: https://github.com/ethereum/wiki/wiki/JSON-RPC\n\nimport { Provider, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { Bytes, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { checkProperties, deepCopy, Deferrable, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { AccessList, accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson, poll } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider, Event } from \"./base-provider\";\n\n\nconst errorGas = [ \"call\", \"estimateGas\" ];\n\nfunction spelunk(value: any, requireData: boolean): null | { message: string, data: null | string } {\n    if (value == null) { return null; }\n\n    // These *are* the droids we're looking for.\n    if (typeof(value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data: null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n\n    // Spelunk further...\n    if (typeof(value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) { return result; }\n        }\n        return null;\n    }\n\n    // Might be a JSON string we can further descend...\n    if (typeof(value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        } catch (error) { }\n    }\n\n    return null;\n}\n\nfunction checkError(method: string, error: any, params: any): any {\n\n    const transaction = params.transaction || params.signedTransaction;\n\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) { return result.data; }\n\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) { result = spelunk(error, false); }\n\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n\n    // @TODO: Should we spelunk for message too?\n\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof(error.error.message) === \"string\") {\n        message = error.error.message;\n    } else if (typeof(error.body) === \"string\") {\n        message = error.body;\n    } else if (typeof(error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nfunction timer(timeout: number): Promise<any> {\n    return new Promise(function(resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n    if (payload.error) {\n        // @TODO: not any\n        const error: any = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n\n    return payload.result;\n}\n\nfunction getLowerCase(value: string): string {\n    if (value) { return value.toLowerCase(); }\n    return value;\n}\n\nconst _constructorGuard = {};\n\nexport class JsonRpcSigner extends Signer implements TypedDataSigner {\n    readonly provider: JsonRpcProvider;\n    _index: number;\n    _address: string;\n\n    constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number) {\n        super();\n\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n\n        defineReadOnly(this, \"provider\", provider);\n\n        if (addressOrIndex == null) { addressOrIndex = 0; }\n\n        if (typeof(addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n\n        } else if (typeof(addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n\n        } else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n\n    connect(provider: Provider): JsonRpcSigner {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n\n    connectUnchecked(): JsonRpcSigner {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n\n    getAddress(): Promise<string> {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index])\n        });\n    }\n\n    sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        transaction = shallowCopy(transaction);\n\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) { address = address.toLowerCase(); }\n            return address;\n        });\n\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then(async (to) => {\n                if (to == null) { return null; }\n                const address = await this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            });\n        }\n\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            } else {\n                tx.from = sender;\n            }\n\n            const hexTx = (<any>this.provider.constructor).hexlifyTransaction(tx, { from: true });\n\n            return this.provider.send(\"eth_sendTransaction\", [ hexTx ]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n\n    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n\n    async sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        // This cannot be mined any earlier than any recent block\n        const blockNumber = await this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n\n        // Send the transaction\n        const hash = await this.sendUncheckedTransaction(transaction);\n\n        try {\n            // Unfortunately, JSON-RPC only provides and opaque transaction hash\n            // for a response, and we need the actual transaction, so we poll\n            // for it; it should show up very quickly\n            return await poll(async () => {\n                const tx = await this.provider.getTransaction(hash);\n                if (tx === null) { return undefined; }\n                return this.provider._wrapTransaction(tx, hash, blockNumber);\n            }, { oncePoll: this.provider });\n        } catch (error) {\n            (<any>error).transactionHash = hash;\n            throw error;\n        }\n    }\n\n    async signMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n        try {\n            return await this.provider.send(\"personal_sign\", [ hexlify(data), address.toLowerCase() ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"signMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _legacySignMessage(message: Bytes | string): Promise<string> {\n        const data = ((typeof(message) === \"string\") ? toUtf8Bytes(message): message);\n        const address = await this.getAddress();\n\n        try {\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return await this.provider.send(\"eth_sign\", [ address.toLowerCase(), hexlify(data) ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_legacySignMessage\",\n                    from: address,\n                    messageData: message\n                });\n            }\n            throw error;\n        }\n    }\n\n    async _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n        // Populate any ENS names (in-place)\n        const populated = await _TypedDataEncoder.resolveNames(domain, types, value, (name: string) => {\n            return this.provider.resolveName(name);\n        });\n\n        const address = await this.getAddress();\n\n        try {\n            return await this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        } catch (error) {\n            if (typeof(error.message) === \"string\" && error.message.match(/user denied/i)) {\n                logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                    action: \"_signTypedData\",\n                    from: address,\n                    messageData: { domain: populated.domain, types, value: populated.value }\n                });\n            }\n            throw error;\n        }\n    }\n\n    async unlock(password: string): Promise<boolean> {\n        const provider = this.provider;\n\n        const address = await this.getAddress();\n\n        return provider.send(\"personal_unlockAccount\", [ address.toLowerCase(), password, null ]);\n    }\n}\n\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return <TransactionResponse>{\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations?: number) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\n\nconst allowedTransactionKeys: { [ key: string ]: boolean } = {\n    chainId: true, data: true, gasLimit: true, gasPrice:true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n}\n\nexport class JsonRpcProvider extends BaseProvider {\n    readonly connection: ConnectionInfo;\n\n    _pendingFilter: Promise<number>;\n    _nextId: number;\n\n    // During any given event loop, the results for a given call will\n    // all be the same, so we can dedup the calls to save requests and\n    // bandwidth. @TODO: Try out generalizing this against send?\n    _eventLoopCache: Record<string, Promise<any>>;\n    get _cache(): Record<string, Promise<any>> {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = { };\n        }\n        return this._eventLoopCache;\n    }\n\n    constructor(url?: ConnectionInfo | string, network?: Networkish) {\n        let networkOrReady: Networkish | Promise<Network> = network;\n\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Default URL\n        if (!url) { url = getStatic<() => string>(this.constructor, \"defaultUrl\")(); }\n\n        if (typeof(url) === \"string\") {\n            defineReadOnly(this, \"connection\",Object.freeze({\n                url: url\n            }));\n        } else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n\n        this._nextId = 42;\n    }\n\n    static defaultUrl(): string {\n        return \"http:/\\/localhost:8545\";\n    }\n\n    detectNetwork(): Promise<Network> {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n\n    async _uncachedDetectNetwork(): Promise<Network> {\n        await timer(0);\n\n        let chainId = null;\n        try {\n            chainId = await this.send(\"eth_chainId\", [ ]);\n        } catch (error) {\n            try {\n                chainId = await this.send(\"net_version\", [ ]);\n            } catch (error) { }\n        }\n\n        if (chainId != null) {\n            const getNetwork = getStatic<(network: Networkish) => Network>(this.constructor, \"getNetwork\");\n            try {\n                return getNetwork(BigNumber.from(chainId).toNumber());\n            } catch (error) {\n                return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                    chainId: chainId,\n                    event: \"invalidNetwork\",\n                    serverError: error\n                });\n            }\n        }\n\n        return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n            event: \"noNetwork\"\n        });\n    }\n\n    getSigner(addressOrIndex?: string | number): JsonRpcSigner {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n\n    getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n\n    listAccounts(): Promise<Array<string>> {\n        return this.send(\"eth_accounts\", []).then((accounts: Array<string>) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([ \"eth_chainId\", \"eth_blockNumber\" ].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n\n            return result;\n\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n\n            throw error;\n        });\n\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n\n        return result;\n    }\n\n    prepareRequest(method: string, params: any): [ string, Array<any> ] {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [ \"eth_blockNumber\", [] ];\n\n            case \"getGasPrice\":\n                return [ \"eth_gasPrice\", [] ];\n\n            case \"getBalance\":\n                return [ \"eth_getBalance\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getTransactionCount\":\n                return [ \"eth_getTransactionCount\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getCode\":\n                return [ \"eth_getCode\", [ getLowerCase(params.address), params.blockTag ] ];\n\n            case \"getStorageAt\":\n                return [ \"eth_getStorageAt\", [ getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag ] ];\n\n            case \"sendTransaction\":\n                return [ \"eth_sendRawTransaction\", [ params.signedTransaction ] ]\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [ \"eth_getBlockByNumber\", [ params.blockTag, !!params.includeTransactions ] ];\n                } else if (params.blockHash) {\n                    return [ \"eth_getBlockByHash\", [ params.blockHash, !!params.includeTransactions ] ];\n                }\n                return null;\n\n            case \"getTransaction\":\n                return [ \"eth_getTransactionByHash\", [ params.transactionHash ] ];\n\n            case \"getTransactionReceipt\":\n                return [ \"eth_getTransactionReceipt\", [ params.transactionHash ] ];\n\n            case \"call\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_call\", [ hexlifyTransaction(params.transaction, { from: true }), params.blockTag ] ];\n            }\n\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic<(t: TransactionRequest, a?: { [key: string]: boolean }) => { [key: string]: string }>(this.constructor, \"hexlifyTransaction\");\n                return [ \"eth_estimateGas\", [ hexlifyTransaction(params.transaction, { from: true }) ] ];\n            }\n\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [ \"eth_getLogs\", [ params.filter ] ];\n\n            default:\n                break;\n        }\n\n        return null;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // Legacy networks do not like the type field being passed along (which\n        // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n        if (method === \"call\" || method === \"estimateGas\") {\n            const tx = params.transaction;\n            if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                // If there are no EIP-1559 properties, it might be non-EIP-1559\n                if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                    const feeData = await this.getFeeData();\n                    if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                        // Network doesn't know about EIP-1559 (and hence type)\n                        params = shallowCopy(params);\n                        params.transaction = shallowCopy(tx);\n                        delete params.transaction.type;\n                    }\n                }\n            }\n        }\n\n        const args = this.prepareRequest(method,  params);\n\n        if (args == null) {\n            logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n        }\n        try {\n            return await this.send(args[0], args[1])\n        } catch (error) {\n            return checkError(method, error, params);\n        }\n    }\n\n    _startEvent(event: Event): void {\n        if (event.tag === \"pending\") { this._startPending(); }\n        super._startEvent(event);\n    }\n\n    _startPending(): void {\n        if (this._pendingFilter != null) { return; }\n        const self = this;\n\n        const pendingFilter: Promise<number> = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n\n        pendingFilter.then(function(filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [ filterId ]).then(function(hashes: Array<string>) {\n                    if (self._pendingFilter != pendingFilter) { return null; }\n\n                    let seq = Promise.resolve();\n                    hashes.forEach(function(hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function() {\n                            return self.getTransaction(hash).then(function(tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n\n                    return seq.then(function() {\n                        return timer(1000);\n                    });\n                }).then(function() {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [ filterId ]);\n                        return;\n                    }\n                    setTimeout(function() { poll(); }, 0);\n\n                    return null;\n                }).catch((error: Error) => { });\n            }\n            poll();\n\n            return filterId;\n        }).catch((error: Error) => { });\n    }\n\n    _stopEvent(event: Event): void {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: { [key: string]: boolean }): { [key: string]: string | AccessList } {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) { allowed[key] = true; }\n            }\n        }\n\n        checkProperties(transaction, allowed);\n\n        const result: { [key: string]: string | AccessList } = {};\n\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            const value = hexValue(BigNumber.from((<any>transaction)[key]));\n            if (key === \"gasLimit\") { key = \"gas\"; }\n            result[key] = value;\n        });\n\n        [\"from\", \"to\", \"data\"].forEach(function(key) {\n            if ((<any>transaction)[key] == null) { return; }\n            result[key] = hexlify((<any>transaction)[key]);\n        });\n\n        if ((<any>transaction).accessList) {\n            result[\"accessList\"] = accessListify((<any>transaction).accessList);\n        }\n\n        return result;\n    }\n}\n","\"use strict\";\n\nimport { arrayify } from \"@ethersproject/bytes\";\n\nimport type { GetUrlResponse, Options } from \"./types\";\n\nexport { GetUrlResponse, Options };\n\nexport async function getUrl(href: string, options?: Options): Promise<GetUrlResponse> {\n    if (options == null) { options = { }; }\n\n    const request: RequestInit = {\n        method: (options.method || \"GET\"),\n        headers: (options.headers || { }),\n        body: (options.body || undefined),\n    };\n\n    if (options.skipFetchSetup !== true) {\n        request.mode = <RequestMode>\"cors\";              // no-cors, cors, *same-origin\n        request.cache = <RequestCache>\"no-cache\";        // *default, no-cache, reload, force-cache, only-if-cached\n        request.credentials = <RequestCredentials>\"same-origin\";  // include, *same-origin, omit\n        request.redirect = <RequestRedirect>\"follow\";    // manual, *follow, error\n        request.referrer = \"client\";                     // no-referrer, *client\n    };\n\n    if (options.fetchOptions != null) {\n        const opts = options.fetchOptions;\n        if (opts.mode) { request.mode = <RequestMode>(opts.mode); }\n        if (opts.cache) { request.cache = <RequestCache>(opts.cache); }\n        if (opts.credentials) { request.credentials = <RequestCredentials>(opts.credentials); }\n        if (opts.redirect) { request.redirect = <RequestRedirect>(opts.redirect); }\n        if (opts.referrer) { request.referrer = opts.referrer; }\n    }\n\n    const response = await fetch(href, request);\n    const body = await response.arrayBuffer();\n\n    const headers: { [ name: string ]: string } = { };\n    if (response.headers.forEach) {\n        response.headers.forEach((value, key) => {\n            headers[key.toLowerCase()] = value;\n        });\n    } else {\n        (<() => Array<string>>((<any>(response.headers)).keys))().forEach((key) => {\n            headers[key.toLowerCase()] = response.headers.get(key);\n        });\n    }\n\n    return {\n        headers: headers,\n        statusCode: response.status,\n        statusMessage: response.statusText,\n        body: arrayify(new Uint8Array(body)),\n    }\n}\n","\"use strict\";\n\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { getUrl, GetUrlResponse, Options } from \"./geturl\";\n\nfunction staller(duration: number): Promise<void> {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n\nfunction bodyify(value: any, type: string): string {\n    if (value == null) { return null; }\n\n    if (typeof(value) === \"string\") { return value; }\n\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            } catch (error) { };\n        }\n        return hexlify(value);\n    }\n\n    return value;\n}\n\n// Exported Types\nexport type ConnectionInfo = {\n    url: string,\n    headers?: { [key: string]: string | number }\n\n    user?: string,\n    password?: string,\n\n    allowInsecureAuthentication?: boolean,\n    allowGzip?: boolean,\n\n    throttleLimit?: number,\n    throttleSlotInterval?: number;\n    throttleCallback?: (attempt: number, url: string) => Promise<boolean>,\n\n    skipFetchSetup?: boolean;\n    fetchOptions?: Record<string, string>;\n    errorPassThrough?: boolean;\n\n    timeout?: number,\n};\n\nexport interface OnceBlockable {\n    once(eventName: \"block\", handler: () => void): void;\n}\n\nexport interface OncePollable {\n    once(eventName: \"poll\", handler: () => void): void;\n}\n\nexport type PollOptions = {\n    timeout?: number,\n    floor?: number,\n    ceiling?: number,\n    interval?: number,\n    retryLimit?: number,\n    onceBlock?: OnceBlockable\n    oncePoll?: OncePollable\n};\n\nexport type FetchJsonResponse = {\n    statusCode: number;\n    headers: { [ header: string ]: string };\n};\n\n\ntype Header = { key: string, value: string };\n\nfunction unpercent(value: string): Uint8Array {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData<T = Uint8Array>(connection: string | ConnectionInfo, body?: Uint8Array, processFunc?: (value: Uint8Array, response: FetchJsonResponse) => T): Promise<T> {\n\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof(connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit: 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0),\n        \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n\n    const throttleCallback = ((typeof(connection) === \"object\") ? connection.throttleCallback: null);\n    const throttleSlotInterval = ((typeof(connection) === \"object\" && typeof(connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval: 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0),\n        \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n\n    const errorPassThrough = ((typeof(connection) === \"object\") ? !!(connection.errorPassThrough): false);\n\n    const headers: { [key: string]: Header } = { };\n\n    let url: string = null;\n\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options: Options = {\n        method: \"GET\",\n    };\n\n    let allow304 = false;\n\n    let timeout = 2 * 60 * 1000;\n\n    if (typeof(connection) === \"string\") {\n        url = connection;\n\n    } else if (typeof(connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n\n        url = connection.url;\n\n        if (typeof(connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n\n        options.allowGzip = !!connection.allowGzip;\n\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\n                    \"basic authentication requires a secure https url\",\n                    Logger.errors.INVALID_ARGUMENT,\n                    { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" }\n                );\n            }\n\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData): null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\")},\n                body: (dataMatch[2] ? base64Decode(dataMatch[3]): unpercent(dataMatch[3]))\n            };\n\n            let result: T = <T><unknown>response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(<T><unknown>result);\n\n        } catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n\n    const flatHeaders: { [ key: string ]: string } = { };\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n\n    const runningTimeout = (function() {\n        let timer: NodeJS.Timer = null;\n        const promise: Promise<never> = new Promise(function(resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) { return; }\n                    timer = null;\n\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n\n        const cancel = function() {\n            if (timer == null) { return; }\n            clearTimeout(timer);\n            timer = null;\n        }\n\n        return { promise, cancel };\n    })();\n\n    const runningFetch = (async function() {\n\n        for (let attempt = 0; attempt < attemptLimit; attempt++) {\n            let response: GetUrlResponse = null;\n\n            try {\n                response = await getUrl(url, options);\n\n                if (attempt < attemptLimit) {\n                    if (response.statusCode === 301 || response.statusCode === 302) {\n                        // Redirection; for now we only support absolute locataions\n                        const location = response.headers.location || \"\";\n                        if (options.method === \"GET\" && location.match(/^https:/)) {\n                            url = response.headers.location;\n                            continue;\n                        }\n\n                    } else if (response.statusCode === 429) {\n                        // Exponential back-off throttling\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            let stall = 0;\n\n                            const retryAfter = response.headers[\"retry-after\"];\n                            if (typeof(retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                stall = parseInt(retryAfter) * 1000;\n                            } else {\n                                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            }\n\n                            //console.log(\"Stalling 429\");\n                            await staller(stall);\n                            continue;\n                        }\n                    }\n                }\n\n            } catch (error) {\n                response = (<any>error).response;\n                if (response == null) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        serverError: error,\n                        url: url\n                    });\n                }\n            }\n\n\n            let body = response.body;\n\n            if (allow304 && response.statusCode === 304) {\n                body = null;\n            } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                runningTimeout.cancel();\n                logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                    status: response.statusCode,\n                    headers: response.headers,\n                    body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                    requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                    requestMethod: options.method,\n                    url: url\n                });\n            }\n\n            if (processFunc) {\n                try {\n                    const result = await processFunc(body, response);\n                    runningTimeout.cancel();\n                    return result;\n\n                } catch (error) {\n                    // Allow the processFunc to trigger a throttle\n                    if (error.throttleRetry && attempt < attemptLimit) {\n                        let tryAgain = true;\n                        if (throttleCallback) {\n                            tryAgain = await throttleCallback(attempt, url);\n                        }\n\n                        if (tryAgain) {\n                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                            //console.log(\"Stalling callback\");\n                            await staller(timeout);\n                            continue;\n                        }\n                    }\n\n                    runningTimeout.cancel();\n                    logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"]: null)),\n                        error: error,\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n            }\n\n            runningTimeout.cancel();\n\n            // If we had a processFunc, it either returned a T or threw above.\n            // The \"body\" is now a Uint8Array.\n            return <T>(<unknown>body);\n        }\n\n        return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n            requestMethod: options.method,\n            url: url\n        });\n    })();\n\n    return Promise.race([ runningTimeout.promise, runningFetch ]);\n}\n\nexport function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any> {\n    let processJsonFunc = (value: Uint8Array, response: FetchJsonResponse) => {\n        let result: any = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            } catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n\n        return result;\n    }\n\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body: Uint8Array = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n\n        // Create a connection with the content-type set for JSON\n        const updated: ConnectionInfo = (typeof(connection) === \"string\") ? ({ url: connection }): shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        } else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n\n    return _fetchData<any>(connection, body, processJsonFunc);\n}\n\nexport function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T> {\n    if (!options) { options = {}; }\n    options = shallowCopy(options);\n    if (options.floor == null) { options.floor = 0; }\n    if (options.ceiling == null) { options.ceiling = 10000; }\n    if (options.interval == null) { options.interval = 250; }\n\n    return new Promise(function(resolve, reject) {\n\n        let timer: NodeJS.Timer = null;\n        let done: boolean = false;\n\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = (): boolean => {\n            if (done) { return false; }\n            done = true;\n            if (timer) { clearTimeout(timer); }\n            return true;\n        };\n\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) { reject(new Error(\"timeout\")); }\n            }, options.timeout)\n        }\n\n        const retryLimit = options.retryLimit;\n\n        let attempt = 0;\n        function check() {\n            return func().then(function(result) {\n\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) { resolve(result); }\n\n                } else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n\n                } else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n\n                // Otherwise, exponential back-off (up to 10s) our next request\n                } else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) { reject(new Error(\"retry limit reached\")); }\n                        return;\n                    }\n\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) { timeout = options.floor; }\n                    if (timeout > options.ceiling) { timeout = options.ceiling; }\n\n                    setTimeout(check, timeout);\n                }\n\n                return null;\n            }, function(error) {\n                if (cancel()) { reject(error); }\n            });\n        }\n        check();\n    });\n}\n\n","export const version = \"web/5.7.1\";\n","\"use strict\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\nimport { version } from \"./_version\";\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nexport class Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map","export const version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map","export const version = \"properties/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CommunityResourcable,\n  JsonRpcProvider\n} from '@ethersproject/providers';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\n\nimport { Network } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { logWarn } from '../util/logger';\nimport { IS_BROWSER } from '../util/util';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(method: string, params: Array<any>, methodName: string): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n    // END MODIFIED CODE\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n"],"names":["decode","textData","atob","data","i","length","push","charCodeAt","arrayify","encode","String","fromCharCode","btoa","logger","Logger","ethDefaultProvider","network","func","providers","options","providerList","InfuraProvider","infura","error","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","skip","provider","indexOf","name","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","chainId","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","getNetwork","standard","throwArgumentError","defaultProvider","value","version","allowedTransactionKeys","forwardErrors","Signer","constructor","checkAbstract","defineReadOnly","this","getBalance","blockTag","_checkProvider","getAddress","getTransactionCount","estimateGas","transaction","tx","resolveProperties","checkTransaction","call","sendTransaction","populateTransaction","signedTx","signTransaction","getChainId","getGasPrice","getFeeData","resolveName","key","shallowCopy","from","Promise","all","resolve","then","result","toLowerCase","to","__awaiter","address","catch","hasEip1559","maxFeePerGas","maxPriorityFeePerGas","gasPrice","type","feeData","throwError","operation","nonce","gasLimit","code","results","static","_isSigner","id","text","keccak256","toUtf8Bytes","padding","Uint8Array","fill","NegativeOne","BigNumber","Zero","One","MaxUint256","hexTrue","hexZeroPad","toHexString","hexFalse","domainFieldTypes","verifyingContract","salt","domainFieldNames","checkString","JSON","stringify","domainChecks","toString","bytes","Error","hexlify","getBaseEncoder","match","signed","width","parseInt","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","padOffset","hexConcat","slice","hexPadRight","encodeType","fields","map","join","TypedDataEncoder","types","Object","freeze","deepCopy","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","getEncoder","encoder","_encoderCache","_getEncoder","subEncoder","encodedType","values","unshift","encodeData","hashStruct","hash","_visit","callback","reduce","accum","visit","domain","domainFields","a","b","EIP712Domain","hashDomain","ensCache","isHexString","domainValues","domainTypes","typesWithDomain","message","ForkEvent","Description","_isForkEvent","Provider","block","getBlock","lastBaseFeePerGas","baseFeePerGas","addListener","eventName","listener","on","removeListener","off","_isProvider","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","j","base","string","k","_leader","q","TypeError","byte","undefined","reverse","Base58","flat","array","depth","flatDeep","arr","val","Array","isArray","read_compressed_payload","pos","read_payload","u16","symbol_count","total","acc","pos_payload","read_width","read_buffer","read_bit","FULL","Math","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","offset","x","decode_arithmetic","read_ascending","next","read_deltas","read_member_array","lookup","vX","vN","read_counts","read_transposed","w","m","read_linear_table","dx","dy","read_zero_terminated_array","ys","_","j_dy","y","read_replacement_table","r","VALID","Set","IGNORED","MAPPED","ret","fromEntries","read_mapped_map","EMOJI_ROOT","sorted","read","branches","set","node","size","temp","valid","fe0f","save","check","read_emoji_trie","explode_cp","toUtf8CodePoints","filter_fe0f","cps","cp","ens_normalize_post_check","label","split","lastIndexOf","every","err","ens_normalize","emoji_filter","input","output","emoji","consume_emoji_reversed","pop","has","toUpperCase","s","fromCodePoint","normalize","eaten","saved","stack","find","splice","Zeros","checkComponent","comp","ensNameSplit","comps","last","namehash","concat","sha256","update","digest","Formatter","formats","getDefaultFormats","bind","bigNumber","hex","number","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","uint256","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","parentHash","timestamp","difficulty","miner","extraData","transactions","blockWithTransactions","transactionResponse","fromBlock","toBlock","filterLog","removed","boolean","allowFalsish","accessListify","toNumber","strict","substring","callAddress","hexDataSlice","getContractAddress","hexValue","hexDataLength","_block","format","author","_difficulty","gas","isZero","networkId","replace","parseTransaction","byzantium","object","checkKey","checkValue","nullValue","replaceValue","checkTopic","topic","serializeTopics","unique","getEventTag","isForkEvent","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","once","_lastBlockNumber","_inflight","event","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","base58Encode","matcherIpfs","RegExp","matchers","_parseString","toUtf8String","_parseBytes","getIpfsLink","link","numPad","padded","bytesPad","ceil","encodeBytes","datas","byteCount","Resolver","resolvedAddress","formatter","supportsWildcard","_supportsEip2544","eq","_fetch","selector","parameters","ccipReadEnabled","parseBytes","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","words","bech32","getAvatar","linkage","content","avatar","getText","scheme","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","fetchJson","imageUrl","image","getContentHash","ipfs","ipns","swarm","skynet","urlSafe","base64Encode","keyBytes","defaultFormatter","nextPollId","BaseProvider","super","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","getStatic","emit","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","ready","poll","ccipReadFetch","calldata","urls","sender","errorMessages","href","json","errorPassThrough","response","statusCode","errorMessage","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","_setFastBlockNumber","pollId","runners","pollingInterval","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","minFromBlock","getLogs","log","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","reject","cancelFuncs","done","alreadyDone","minedHandler","lastBlockNumber","startBlock","scannedBlock","replaceHandler","mined","getTransaction","getBlockWithTransactions","ti","reason","cancelled","replacement","_wrapTransaction","timer","unref","clearTimeout","method","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","signedTransaction","hexTx","_getTransactionRequest","_getFilter","_call","attempt","redirects","txSender","signature","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipResult","resolved","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getEtherPrice","getResolver","currentName","_getResolver","resolver","addrData","lookupAddress","resolverAddr","nameOrAddress","resolverAddress","_startEvent","e","_stopEvent","_addEventListener","args","stopped","eventTag","apply","listenerCount","listeners","removeAllListeners","errorGas","spelunk","requireData","parse","checkError","body","responseText","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","action","signMessage","messageData","_legacySignMessage","_signTypedData","populated","_TypedDataEncoder","unlock","password","networkOrReady","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","request","jsonrpc","cache","connection","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","getUrl","headers","skipFetchSetup","mode","credentials","redirect","referrer","fetchOptions","opts","fetch","arrayBuffer","get","statusMessage","statusText","staller","bodyify","isBytesLike","trim","processFunc","updated","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","allow304","allowGzip","user","allowInsecureAuthentication","argument","authorization","reData","dataMatch","base64Decode","requestBody","requestMethod","flatHeaders","header","runningTimeout","promise","cancel","runningFetch","location","tryAgain","retryAfter","random","pow","throttleRetry","race","_fetchData","ceiling","interval","retryLimit","onceBlock","_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","_logLevel","_globalLogger","_normalizeError","missing","form","_checkNormalize","LogLevel","ErrorCode","HEX","defineProperty","enumerable","writable","_log","logLevel","level","console","levels","DEBUG","INFO","WARNING","errors","UNKNOWN_ERROR","messageDetails","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","INVALID_ARGUMENT","assert","condition","checkNormalize","UNSUPPORTED_OPERATION","checkSafeUint53","checkArgumentCount","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","checkNew","target","kind","censorship","permanent","globalLogger","opaque","bigint","_isFrozen","isFrozen","_deepCopy","item","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","maxRetries","EthersNetwork","DEFAULT_ALCHEMY_API_KEY","CustomNetworks","getNetworkFromEthers","DEFAULT_NETWORK","Network","includes","getAlchemyHttpUrl","getAlchemyWsUrl","IS_BROWSER","VERSION","_super","logWarn","isCommunityResource","_send","methodName","ALPHABET","ALPHABET_MAP","z","polymodStep","pre","prefixChk","chk","c","__decode","str","LIMIT","lowered","uppered","wordChars","convert","inBits","outBits","pad","bits","maxV","module","exports","decodeUnsafe","res","arguments","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords"],"sourceRoot":""}